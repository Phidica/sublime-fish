<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>fish</string>
	</array>
	<key>firstLineMatch</key>
	<string>^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-</string>
	<key>foldingStartMarker</key>
	<string>\b(begin|case|for|if|else|function|switch|while)\b|(\{)$</string>
	<key>foldingStopMarker</key>
	<string>^\s*(\}|(case|else|end)\b)</string>
	<key>keyEquivalent</key>
	<string>^~S</string>
	<key>name</key>
	<string>Shell Script (fish)</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>comment</key>
			<string>These are the patterns which can appear in the base scope</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#block</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#command-call</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comment</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#control-operator</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#escape-character</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>argument</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=^|\s)(?!\s|#|$)</string>
					<key>comment</key>
					<string>End arg if it precedes whitespace, unescaped control operators, or a newline</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\s|\)|;|&amp;|\||$)</string>
					<key>name</key>
					<string>meta.function-call.argument.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Arguments are made of strings, either quoted or unquoted. The unquoted string handles numerics, character escapes, command substitutions, and brace/variable/process expansions</string>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>block</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(begin)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.begin.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(while)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.while.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(if)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.if.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call</string>
							<key>match</key>
							<string>\b(else(\s*if)?)\b</string>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(for)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.for-in.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=for)</string>
							<key>end</key>
							<string>(?&lt;=\w)(?=\W)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Treat the varname like an argument</string>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(in)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Treat the list as arguments</string>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(switch)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.switch.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=switch)</string>
							<key>comment</key>
							<string>Value ends before ';' or at a newline</string>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>name</key>
							<string>meta.block.switch.value.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(case)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Case block ends before a new case or the end of the switch block</string>
							<key>end</key>
							<string>(?=\b(case|end)\b)</string>
							<key>name</key>
							<string>meta.block.switch.case.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=case)</string>
									<key>comment</key>
									<string>Wildcard ends before ';' or at a newline</string>
									<key>end</key>
									<string>(?=;)|\n</string>
									<key>name</key>
									<string>meta.block.switch.case.wildcard.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#argument</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-inline</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#control-operator</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(function)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=function)</string>
							<key>comment</key>
							<string>Name and options end before ';' or at a newline</string>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=function)\s+</string>
									<key>comment</key>
									<string>Detect the region from just after the `function` command to between the defined function name the argument or control operators which follow it. Note that we have to account for the fact the defined function name may end in an escaped space</string>
									<key>end</key>
									<string>(?&lt;=\S|\\ )\s*(?=\S|;|\n)</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>comment</key>
											<string>The function name may be given using any means that is valid for a command call</string>
											<key>match</key>
											<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
											<key>name</key>
											<string>entity.name.function.fish</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-inline</string>
										</dict>
										<dict>
											<key>comment</key>
											<string>We can't read across lines, so this is needed to catch an escaped newline at the start of a defined function name</string>
											<key>match</key>
											<string>\\\n</string>
											<key>name</key>
											<string>constant.character.escape</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>comment</key>
									<string>The rest of the patterns are the typical elements of a standard command-call, which is what the `function` command adheres to</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(return)\b(?!\s+(-))</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The `return` command can't accept flags</string>
							<key>end</key>
							<string>(?=\)|;)|\n|(&amp;|\|)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b((builtin|command|exec)|(and|not|or))\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>support.function.builtin.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Recursive command-call ends before ')' or ';', and just after a newline, '&amp;', or '|'. Standard command-call will have consumed the '&amp;' or '|'. Unfortunately, we cannot help but end after any newline we encounter, as the standard command-call only ends when it consumes a newline (allowing us to insert comments by having the comment consume its newline and prevent command-call matching it) and we cannot distinguish between a newline that was consumed by a command and a newline that was consumed by a comment. Put simply, this means that when a recursive command-call reaches a newline before its first standard command-call, the scope ends and the standard command-call on the next line loses the recursive command-call scope</string>
					<key>end</key>
					<string>(?=\)|;)|(?&lt;=\n|&amp;|\|)</string>
					<key>name</key>
					<string>meta.function-call.recursive.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#command-call</string>
						</dict>
						<dict>
							<key>captures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>constant.character.escape</string>
								</dict>
							</dict>
							<key>match</key>
							<string>(\\)\n</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(?:case|else|end)\b|(?&lt;=^|\(|;|&amp;|\|\s)(?:%)</string>
					<key>comment</key>
					<string>Search for illegal commands; these aren't valid outside of their use in blocks</string>
					<key>end</key>
					<string>$\n?</string>
					<key>name</key>
					<string>invalid.illegal.function.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>support.function.user.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Command call ends before ')' or ';', and at a newline, '&amp;', or '|'. Those last two control operators must be part of a command, so consume them here</string>
					<key>end</key>
					<string>(?=\)|;)|\n|(&amp;|\|)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function-call.standard.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#argument</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-substitution</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\()</string>
					<key>comment</key>
					<string>Capture "(...)" or "(...)[...]"</string>
					<key>end</key>
					<string>(?&lt;=\))(?!\[)|(?&lt;=\])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\(</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.command-substitution.begin.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The inside of a command substitution is indistinguishable from a global scope</string>
							<key>end</key>
							<string>\)</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.command-substitution.end.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.command-substitution.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\[</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.index-expansion.begin.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>\]</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.index-expansion.end.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.index-expansion.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Consumes the remainder of a line after any character which marks the start of a scope with no commands in it. Consumes the newline, thus hiding the entire comment from any scope which seeks newlines</string>
					<key>match</key>
					<string>(?&lt;=^|else|end|\(|;|&amp;|\|)\s*(#).*$\n?</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>comment-inline</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Separate from comment as this is only valid inside of command-call. Does not consume the newline, thus allowing command-call to capture it and end</string>
					<key>match</key>
					<string>(#).*$</string>
					<key>name</key>
					<string>comment.line.insert.fish</string>
				</dict>
			</array>
		</dict>
		<key>control-operator</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This is the only operator which is allowed to exist alone on a line. The other control operators are '&amp;' and '|' however they must be preceded by a command, so command-call matches those</string>
					<key>match</key>
					<string>;</string>
					<key>name</key>
					<string>keyword.control.fish punctuation.definition.keyword.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>These two control operators, '&amp;' and '|', must be preceded by a command, so command patterns match them when they are valid. If they are found in the global scope or first inside a command-substitution, that means they are dangling</string>
					<key>match</key>
					<string>(?&lt;=^|\(|;|&amp;|\|)\s*(&amp;|\|).*$\n?</string>
					<key>name</key>
					<string>invalid.illegal.control.fish</string>
				</dict>
			</array>
		</dict>
		<key>escape-character</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This match should only be needed for an escaped newline which is not part of any command-call, like if it comes alone on a line. No need to consume the newline</string>
					<key>match</key>
					<string>\\(?=\n)</string>
					<key>name</key>
					<string>constant.character.escape</string>
				</dict>
			</array>
		</dict>
		<key>loop-control-command</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(break|continue)\b(?!\s+(-|\w))</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>These commands only work as loop control when they are used without arguments</string>
					<key>end</key>
					<string>(?=;)|\n|(&amp;)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#control-operator</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#escape-character</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>math</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Only match an operator if the element to the right is whitespace/newline, a variable, or command substitution</string>
					<key>match</key>
					<string>(\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|&lt;[&lt;=]?|&gt;[&gt;=]?|==|!=|^|\|{1,2}|&amp;{1,2}|\?|\:|,|=|[*/%+\-&amp;^|]=|&lt;&lt;=|&gt;&gt;=)(?=(\s|$|\$|\())</string>
					<key>name</key>
					<string>keyword.operator.arithmetic.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>0[xX]\h+</string>
					<key>name</key>
					<string>constant.numeric.hex.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>0\d+</string>
					<key>name</key>
					<string>constant.numeric.octal.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\d{1,2}#[0-9a-zA-Z@_]+</string>
					<key>name</key>
					<string>constant.numeric.other.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\d+</string>
					<key>name</key>
					<string>constant.numeric.integer.fish</string>
				</dict>
			</array>
		</dict>
		<key>pathname</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?&lt;=\s|:|=|^)~</string>
					<key>name</key>
					<string>keyword.operator.tilde.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\*|\?</string>
					<key>name</key>
					<string>keyword.operator.glob.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>([?*+@!])(\()</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.extglob.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.extglob.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\))</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.extglob.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.structure.extglob.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>redirection</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>[&gt;&lt;]\(</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\)</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.interpolated.process-substitution.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>comment</key>
					<string>valid: &amp;&gt;word &gt;&amp;word &gt;word [n]&gt;&amp;[n] [n]&lt;word [n]&gt;word [n]&gt;&gt;word [n]&lt;&amp;word (last one is duplicate)</string>
					<key>match</key>
					<string>&amp;&gt;|\d*&gt;&amp;\d*|\d*(&gt;&gt;|&gt;|&lt;)|\d*&lt;&amp;|\d*&lt;&gt;</string>
					<key>name</key>
					<string>keyword.operator.redirect.fish</string>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#string-quoted</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string-unquoted</string>
				</dict>
			</array>
		</dict>
		<key>string-quoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \' and \\</string>
							<key>match</key>
							<string>\\[\'\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \", \$, \&lt;newline&gt;, and \\</string>
							<key>match</key>
							<string>\\[\"$\n\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Variable expansion is the only expansion permitted</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\'|\"|\[|\{|\%|^|\s)(?!\'|\"|\]|\}|\s)</string>
					<key>comment</key>
					<string>End string if it precedes the begin of a quoted string, the end of an index/brace expansion (but not a process expansion as '%' is valid in names), or anything that would end an argument</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\'|\"|\]|\}|\s|\)|;|&amp;|\||$)</string>
					<key>name</key>
					<string>string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string-unquoted-patterns</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns</key>
		<dict>
			<key>comment</key>
			<string>Describes contents of an unquoted string separately for ease of recursion</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Treat integers as standalone constants if they aren't within strings of alphanumeric characters</string>
					<key>match</key>
					<string>(?&lt;![0-9A-Za-z])[0-9]+(?![0-9A-Za-z])</string>
					<key>name</key>
					<string>constant.numeric.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>This list follows the order given in official fish documentation, with the addition of an escaped newline match and additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument</string>
					<key>match</key>
					<string>\\\n|\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;|;"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]</string>
					<key>name</key>
					<string>constant.character.escape.fish</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#command-substitution</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#variable-expansion</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.brace-expansion.begin.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\}</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.brace-expansion.end.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.brace-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Explicitly treat ',' as a keyword</string>
							<key>match</key>
							<string>\,</string>
							<key>name</key>
							<string>keyword.control.brace-expansion.separator.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?&lt;=\,|\'|\"|\[|\{|^|\s)(?!\,|\'|\"|\]|\}|\s)</string>
							<key>comment</key>
							<string>Begin/end string at same boundaries as before, but ',' can also force a start/stop</string>
							<key>end</key>
							<string>(?&lt;=.|\n)(?=\,|\'|\"|\]|\}|\s|\)|;|&amp;|\||$)</string>
							<key>name</key>
							<string>string.unquoted.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Explicitly allow a ',' to be escaped</string>
									<key>match</key>
									<string>\\\,</string>
									<key>name</key>
									<string>constant.character.escape.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\%</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.process.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Process expansion assumed to continue for the entire argument</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\s|\)|;|&amp;|\||$)</string>
					<key>name</key>
					<string>constant.other.process.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for string.unquoted</string>
					<key>match</key>
					<string>\$(?:(?=[,'"\]}\s);&amp;|])|[^\w\$][^$,'"\]}\s);&amp;|]*)</string>
					<key>name</key>
					<string>invalid.illegal.variable-expansion.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\$)</string>
					<key>comment</key>
					<string>Capture "$foo" or "$foo[]"</string>
					<key>end</key>
					<string>(?&lt;=[\$\w])(?=[^\$\w\[])|(?&lt;=\])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\$</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.variable.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Capture "foo"[ or "foo[...]"[</string>
							<key>end</key>
							<string>(?&lt;=[\$\w\]])(?=[^\$\w])|(?&lt;=\])(?=\[)</string>
							<key>name</key>
							<string>variable.other.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#variable-expansion</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\[</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.index-expansion.begin.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>In other words, the anonymous scope which contains the variable and the index expansion argument list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack</string>
							<key>end</key>
							<string>\]</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.index-expansion.end.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.index-expansion.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.fish</string>
	<key>uuid</key>
	<string>a6b750ed-a12a-43c1-84e7-689ac7e2fbc9</string>
</dict>
</plist>
