<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>fish</string>
	</array>
	<key>firstLineMatch</key>
	<string>^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-</string>
	<key>foldingStartMarker</key>
	<string>\b(begin|case|for|if|else|function|switch|while)\b|(\{)$</string>
	<key>foldingStopMarker</key>
	<string>^\s*(\}|(case|else|end)\b)</string>
	<key>keyEquivalent</key>
	<string>^~S</string>
	<key>name</key>
	<string>Shell Script (fish)</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>comment</key>
			<string>These are the patterns which can appear in the base scope</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#block</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#command-call</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comment</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#control-operator</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#escape-character</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>argument</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=^|\s)(?!\s|#|$)</string>
					<key>comment</key>
					<string>End arg if it precedes whitespace, unescaped control operators, or a newline</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\s|\)|;|&amp;|\||$)</string>
					<key>name</key>
					<string>meta.function-call.argument.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Arguments are made of strings, either quoted or unquoted. The unquoted string covers constants, escapes, command substitutions, and variable substitutions</string>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>block</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(begin)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.begin.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(while)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.while.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(if)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.if.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call</string>
							<key>match</key>
							<string>\b(else(\s*if)?)\b</string>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(for)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.for-in.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=for)</string>
							<key>end</key>
							<string>^</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>(\w+)(\s+((\\)\n)?)+(in)\s+</string>
									<key>beginCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.argument.fish</string>
										</dict>
										<key>5</key>
										<dict>
											<key>name</key>
											<string>keyword.control.conditional.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Treat the varname to `for` like a normal argument</string>
									<key>contentName</key>
									<string>meta.function-call.argument.fish</string>
									<key>end</key>
									<string>\n</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>captures</key>
											<dict>
												<key>1</key>
												<dict>
													<key>name</key>
													<string>constant.character.escape</string>
												</dict>
											</dict>
											<key>match</key>
											<string>(\\)\n</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#command-substitution</string>
										</dict>
										<dict>
											<key>comment</key>
											<string>Treat values to `in` like normal arguments</string>
											<key>match</key>
											<string>\w+</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(switch)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.switch.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=switch)</string>
							<key>comment</key>
							<string>Value ends before ';' or at a newline</string>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>name</key>
							<string>meta.block.switch.value.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(case)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Case block ends before a new case or the end of the switch block</string>
							<key>end</key>
							<string>(?=\b(case|end)\b)</string>
							<key>name</key>
							<string>meta.block.switch.case.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=case)</string>
									<key>comment</key>
									<string>Wildcard ends before ';' or at a newline</string>
									<key>end</key>
									<string>(?=;)|\n</string>
									<key>name</key>
									<string>meta.block.switch.case.wildcard.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#argument</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-inline</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#control-operator</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(function)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b((builtin|command|exec)|(and|not|or))\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>support.function.builtin.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Recursive command-call ends before ')' or ';', and just after a newline, '&amp;', or '|'. Standard command-call will have consumed the '&amp;' or '|'. Unfortunately, we cannot help but end after any newline we encounter, as the standard command-call only ends when it consumes a newline (allowing us to insert comments by having the comment consume its newline and prevent command-call matching it) and we cannot distinguish between a newline that was consumed by a command and a newline that was consumed by a comment. Put simply, this means that when a recursive command-call reaches a newline before its first standard command-call, the scope ends and the standard command-call on the next line loses the recursive command-call scope</string>
					<key>end</key>
					<string>(?=\)|;)|(?&lt;=\n|&amp;|\|)</string>
					<key>name</key>
					<string>meta.function-call.recursive.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#command-call</string>
						</dict>
						<dict>
							<key>captures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>constant.character.escape</string>
								</dict>
							</dict>
							<key>match</key>
							<string>(\\)\n</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(case|else|end)\b</string>
					<key>comment</key>
					<string>These functions aren't valid outside of their blocks</string>
					<key>end</key>
					<string>$\n?</string>
					<key>name</key>
					<string>invalid.illegal.function.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[ \\|$*?%#(){}\[\]&lt;&gt;^&amp;;"']|[^\s\\|$*?%#(){}\[\]&lt;&gt;^&amp;;"'])+)+</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>support.function.user.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Command call ends before ')' or ';', and at a newline, '&amp;', or '|'. Those last two control operators must be part of a command, so consume them here</string>
					<key>end</key>
					<string>(?=\)|;)|\n|(&amp;|\|)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function-call.standard.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#argument</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-substitution</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\(</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.command-substitution.begin.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>The inside of a command substitution is indistinguishable from a global scope</string>
					<key>end</key>
					<string>\)</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.command-substitution.end.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.command-substitution.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Consumes the remainder of a line after any character which marks the start of a scope with no commands in it. Consumes the newline, thus hiding the entire comment from any scope which seeks newlines</string>
					<key>match</key>
					<string>(?&lt;=^|else|end|\(|;|&amp;|\|)\s*(#).*$\n?</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>comment-inline</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Separate from comment as this is only valid inside of command-call. Does not consume the newline, thus allowing command-call to capture it and end</string>
					<key>match</key>
					<string>(#).*$</string>
					<key>name</key>
					<string>comment.line.insert.fish</string>
				</dict>
			</array>
		</dict>
		<key>control-operator</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This is the only operator which is allowed to exist alone on a line. The other control operators are '&amp;' and '|' however they must be preceded by a command, so command-call matches those</string>
					<key>match</key>
					<string>;</string>
					<key>name</key>
					<string>keyword.control.fish punctuation.definition.keyword.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>These two control operators, '&amp;' and '|', must be preceded by a command, so command patterns match them when they are valid. If they are found in the global scope or first inside a command-substitution, that means they are dangling</string>
					<key>match</key>
					<string>(?&lt;=^|\(|;|&amp;|\|)\s*(&amp;|\|).*$\n?</string>
					<key>name</key>
					<string>invalid.illegal.control.fish</string>
				</dict>
			</array>
		</dict>
		<key>escape-character</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This match should only be needed for an escaped newline which is not part of any command-call, like if it comes alone on a line. No need to consume the newline</string>
					<key>match</key>
					<string>\\(?=\n)</string>
					<key>name</key>
					<string>constant.character.escape</string>
				</dict>
			</array>
		</dict>
		<key>function-definition</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(function)\s+([^\s\\]+)(?:\s*(\(\)))?</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.function.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.function.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.arguments.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>;|&amp;|$</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.function.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>logical-expression</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>do we want a special rule for ( expr )?</string>
					<key>match</key>
					<string>=[=~]?|!=?|&lt;|&gt;|&amp;&amp;|\|\|</string>
					<key>name</key>
					<string>keyword.operator.logical.fish</string>
				</dict>
			</array>
		</dict>
		<key>loop-control-command</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(break|continue)\b(?!\s+(-|\w))</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>These commands only work as loop control when they are used without arguments</string>
					<key>end</key>
					<string>(?=;)|\n|(&amp;)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#control-operator</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#escape-character</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>math</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Only match an operator if the element to the right is whitespace/newline, a variable, or command substitution</string>
					<key>match</key>
					<string>(\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|&lt;[&lt;=]?|&gt;[&gt;=]?|==|!=|^|\|{1,2}|&amp;{1,2}|\?|\:|,|=|[*/%+\-&amp;^|]=|&lt;&lt;=|&gt;&gt;=)(?=(\s|$|\$|\())</string>
					<key>name</key>
					<string>keyword.operator.arithmetic.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>0[xX]\h+</string>
					<key>name</key>
					<string>constant.numeric.hex.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>0\d+</string>
					<key>name</key>
					<string>constant.numeric.octal.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\d{1,2}#[0-9a-zA-Z@_]+</string>
					<key>name</key>
					<string>constant.numeric.other.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\d+</string>
					<key>name</key>
					<string>constant.numeric.integer.fish</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#variable</string>
				</dict>
			</array>
		</dict>
		<key>pathname</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?&lt;=\s|:|=|^)~</string>
					<key>name</key>
					<string>keyword.operator.tilde.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\*|\?</string>
					<key>name</key>
					<string>keyword.operator.glob.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>([?*+@!])(\()</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.extglob.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.extglob.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\))</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.extglob.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.structure.extglob.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>redirection</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>[&gt;&lt;]\(</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\)</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.interpolated.process-substitution.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>comment</key>
					<string>valid: &amp;&gt;word &gt;&amp;word &gt;word [n]&gt;&amp;[n] [n]&lt;word [n]&gt;word [n]&gt;&gt;word [n]&lt;&amp;word (last one is duplicate)</string>
					<key>match</key>
					<string>&amp;&gt;|\d*&gt;&amp;\d*|\d*(&gt;&gt;|&gt;|&lt;)|\d*&lt;&amp;|\d*&lt;&gt;</string>
					<key>name</key>
					<string>keyword.operator.redirect.fish</string>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \' and \\</string>
							<key>match</key>
							<string>\\[\'\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \", \$, \&lt;newline&gt;, and \\</string>
							<key>match</key>
							<string>\\[\"$\n\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Variable substitution is the only substitution permitted</string>
							<key>include</key>
							<string>#variable</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?&lt;=^|\s|\'|\")(?!\'|\")</string>
					<key>comment</key>
					<string>End string if it precedes the begin of a quoted string or anything that would end an argument</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\'|\"|\s|\)|;|&amp;|\||$)</string>
					<key>name</key>
					<string>string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Treat integers as standalone constants if they aren't within strings of alphanumeric characters</string>
							<key>match</key>
							<string>(?&lt;![A-z0-9])[0-9]+(?![A-z0-9])</string>
							<key>name</key>
							<string>constant.numeric.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>This list follows the order given in official fish documentation, with the addition of an escaped newline match</string>
							<key>match</key>
							<string>\\\n|\\[abefnrtv $\\*?~%#(){}\[\]&lt;&gt;^&amp;;"']|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[A-z]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(\$)\w+(?=\[)</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>variable.other.fish</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.variable.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=\])</string>
					<key>name</key>
					<string>meta.item-access.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\[</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.arguments.begin.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>\]</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.arguments.end.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.item-access.arguments.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Not even fish does its item-access highlighting this well</string>
									<key>include</key>
									<string>#variable</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.variable.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>fish variables can only be word characters and no special treatment is necessary</string>
					<key>match</key>
					<string>(\$)\w+(?=\W)</string>
					<key>name</key>
					<string>variable.other.fish</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.fish</string>
	<key>uuid</key>
	<string>a6b750ed-a12a-43c1-84e7-689ac7e2fbc9</string>
</dict>
</plist>
