<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>fish</string>
	</array>
	<key>firstLineMatch</key>
	<string>^#!.*\b(fish)\b</string>
	<key>name</key>
	<string>Friendly Interactive Shell (fish)</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#comment</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#line-continuation</string>
		</dict>
		<dict>
			<key>begin</key>
			<string>\)|end</string>
			<key>comment</key>
			<string>In an ideal world,</string>
			<key>end</key>
			<string>(?=[\s);&amp;|&lt;&gt;])</string>
			<key>name</key>
			<string>invalid.illegal.function-call.fish</string>
		</dict>
		<dict>
			<key>comment</key>
			<string>The first character of a pipeline can't be an '&amp;', and the base pipeline scope won't be able to mark it as invalid so we have to do so here</string>
			<key>match</key>
			<string>\&amp;</string>
			<key>name</key>
			<string>invalid.illegal.function-call.fish</string>
		</dict>
		<dict>
			<key>begin</key>
			<string>(?=\S)</string>
			<key>comment</key>
			<string>Anonymous scope - Base scope pipeline, goes up until a definitive end (typical control operators, or a comment to finish the line) or the sequences that could be an end if we're actually inside a $self scope right now (')' and "end")</string>
			<key>end</key>
			<string>(\n)|([;&amp;])|(?=\)|#|end)</string>
			<key>endCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>meta.function-call.operator.control.fish</string>
				</dict>
				<key>2</key>
				<dict>
					<key>name</key>
					<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
				</dict>
			</dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#pipeline</string>
				</dict>
			</array>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>argument</key>
		<dict>
			<key>comment</key>
			<string>This rule must be entirely standalone because it is used in scopes where parameters starting with hyphens are explicitly interpreted as arguments rather than as options</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?![\s);&amp;|&lt;&gt;^])</string>
					<key>comment</key>
					<string>End arg if it precedes whitespace or operators (excluding stderr redirect '^' due to a fish quirk)</string>
					<key>end</key>
					<string>(?=[\s);&amp;|&lt;&gt;])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\%</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.string.unquoted.fish punctuation.definition.process.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Process expansion only occurs if the '%' is at the front of the argument, and continues for the entire argument</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.argument.process-expansion.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Match special process names. By a convention that I'm making up, scope them as a type of variable</string>
									<key>match</key>
									<string>(?:self|last)(?=$|[\s);&amp;|&lt;&gt;])</string>
									<key>name</key>
									<string>meta.string.unquoted.fish variable.language.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#parameter-patterns</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Treat a sequence of integers (with possible sign and decimal separator) as a standalone constant. Do this separate to the</string>
							<key>match</key>
							<string>(?:[+-]?)(?:[0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)(?=$|[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.argument.numeric.fish meta.string.unquoted.fish constant.numeric.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?![\s($])</string>
							<key>comment</key>
							<string>This scope can be used by plugins to locate arguments which don't *start* with command substitution or variable expansion and may directly resolve to file paths. Of course, they could have command substitution or variable expansion further on in them, but looking ahead for that too is nontrivial</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.argument.path.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Home directory expansion only occurs if the '~' is at the front of the argument, so check it first</string>
									<key>match</key>
									<string>\~</string>
									<key>name</key>
									<string>meta.string.unquoted.fish keyword.operator.tilde.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#parameter-patterns</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?!\s)</string>
							<key>comment</key>
							<string>Use standard parameter patterns for whatever doesn't match the above</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.argument.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#parameter-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-meta</key>
		<dict>
			<key>comment</key>
			<string>Check if the command is a builtin which takes another command as parameters, ie, a meta command. However, ignore the command if it is taking an option, being backgrounded/piped, or in some cases redirected, as in such a case it should be picked up by</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?x)
(builtin|command|exec)\b
(?# Look ahead for control operations after whitespace)
(?!\s*
  (?:
    (?# Find simple control operations)
    [\n)#;&amp;|]
  |
    (?# Find redirection, which may be into a pipe but we don't care)
    (?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?
  |
    (?# Find options)
    -
  )
)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish support.function.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>These meta commands force the parameter to behave as a standard command. They stop when their subcommand is piped. Notably, if the command is followed by redirection, then the redirection is legal and the command just prints its help text, so in that case we avoid opening this scope such that the command is caught elsewhere as a standard command</string>
					<key>end</key>
					<string>(?x)
(?# Look ahead for control operations after whitespace)
(?=\s*
  (?:
    (?# Find simple control operations)
    [\n)#;&amp;]
  |
    (?# Find piping)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  )
)</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#separator-whitespace</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-standard</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=(not)\b(?!\s*[\n)#;-]))</string>
					<key>comment</key>
					<string>If the command is followed by redirection, then the redirection is illegal so we have to open the scope and let it be caught by</string>
					<key>end</key>
					<string>(?=[\n)#;&amp;])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(not)\b(?!\s*[\n);-])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.name.fish keyword.operator.word.fish meta.string.unquoted.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>If the command is followed by an "&amp;", then that's invalid</string>
							<key>end</key>
							<string>(?![^\n\S]|\&amp;|\\\n)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#separator-whitespace</string>
								</dict>
								<dict>
									<key>match</key>
									<string>\&amp;</string>
									<key>name</key>
									<string>invalid.illegal.function-call.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#pipeline</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-standard</key>
		<dict>
			<key>comment</key>
			<string>Check if the command is any other legal command, ie, a standard command</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\S)</string>
					<key>comment</key>
					<string>Anonymous scope - A complete command comprising a name element and optional parameter, redirection, and comment elements</string>
					<key>end</key>
					<string>(?x)
(?# Look ahead for operators)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;]
  |
    (?# Find a pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  )
)</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?![\s&lt;&gt;^%])</string>
							<key>comment</key>
							<string>Anonymous scope - A name or block element. If a block is found, everything up to the `end` command is captured here. Note that redirection and process expansion can't start the element</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Look for block structures</string>
									<key>include</key>
									<string>#command-call-standard-block</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>\[(?=[\s&lt;&gt;]|\\\n)</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.name.fish support.function.test.begin.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Look for the alternate form of test, which uses a matching pair of '[' ']'</string>
									<key>end</key>
									<string>(\])|(\n|[;&amp;)|].*)</string>
									<key>endCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.name.fish support.function.test.end.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>invalid.illegal.function-call.fish</string>
										</dict>
									</dict>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#separator-whitespace</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#parameter</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#redirection</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>captures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Look for loop/function control commands. We perform no checking on the validity of their scope (because only allowing them in the correct scope won't work if they are used within if-blocks) or parameters (because fish does that during execution not parsing)</string>
									<key>match</key>
									<string>(?:break|continue|return)(?=[\s);&amp;|&lt;&gt;])</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?!\s)</string>
									<key>comment</key>
									<string>Anonymous scope - A generic name element</string>
									<key>end</key>
									<string>(?=[\s);&amp;|&lt;&gt;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>begin</key>
											<string>(?=\()</string>
											<key>comment</key>
											<string>fish would match the whole command name invalid if there was a command substitution anywhere in it, but we can't look ahead that effectively</string>
											<key>end</key>
											<string>(?=[\s);&amp;|&lt;&gt;])</string>
											<key>name</key>
											<string>invalid.illegal.function-call.fish</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>begin</key>
													<string>\(</string>
													<key>end</key>
													<string>\)|(?=[\n);&amp;|&lt;&gt;])</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>begin</key>
											<string>(?!\s)</string>
											<key>comment</key>
											<string>Otherwise, treat the element as a fraction of a name made of arbitrary strings (which breaks at an escaped newline)</string>
											<key>end</key>
											<string>(?=[\s);&amp;(|&lt;&gt;])</string>
											<key>name</key>
											<string>meta.function-call.name.fish variable.function.fish</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>comment</key>
													<string>The string scope explicitly forbids '$' so that the argument rule can pick it up as a variable expansion, but '$' is treated as a literal in command names, so we have to match it separately</string>
													<key>match</key>
													<string>\$</string>
													<key>name</key>
													<string>meta.string.unquoted.fish</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#string</string>
												</dict>
											</array>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\%</string>
							<key>comment</key>
							<string>A command name can't begin with a process expansion operator (however the variable expansion operator '$' is allowed)</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>invalid.illegal.function-call.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#redirection</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=[^\n\S]+)</string>
							<key>comment</key>
							<string>Match any whitespace characters that aren't the newline</string>
							<key>end</key>
							<string>(?x)
(?# Look ahead for operators)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;]
  |
    (?# Find a pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  )
)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?!--[\s);&amp;|&lt;&gt;])</string>
									<key>comment</key>
									<string>A list of elements that does not start with an end-of-options parameter</string>
									<key>end</key>
									<string>(?x)
(?# Look ahead for operators or the end of options)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;]
  |
    (?# Find a pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  |
    (?# Find a double hyphen)
    --[\s);&amp;|&lt;&gt;]
  )
)</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#separator-whitespace</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#redirection</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#parameter</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?=--[\s);&amp;|&lt;&gt;])</string>
									<key>comment</key>
									<string>A list of elements that starts with an end-of-options parameter</string>
									<key>end</key>
									<string>(?x)
(?# Look ahead for operators)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;]
  |
    (?# Find a pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  )
)</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>begin</key>
											<string>(?=--[\s);&amp;|&lt;&gt;])</string>
											<key>comment</key>
											<string>Contain just the end-of-options parameter and give it the normal scope</string>
											<key>end</key>
											<string>(?=[\s);&amp;|&lt;&gt;])</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>#parameter</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>begin</key>
											<string>(?=\s)</string>
											<key>comment</key>
											<string>A list of elements (now forcibly using arguments)</string>
											<key>end</key>
											<string>(?x)
(?# Look ahead for operators)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;]
  |
    (?# Find a pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  )
)</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>#separator-whitespace</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#line-continuation</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#redirection</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#argument</string>
												</dict>
											</array>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-standard-block</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish variable.function.fish meta.string.unquoted.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.operator.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Block commands cannot be backgrounded, piped, or redirected</string>
					<key>match</key>
					<string>(begin|while|if|for|switch|function)\s*([&amp;|&lt;&gt;])</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish variable.function.fish meta.string.unquoted.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.operator.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>The begin command uniquely cannot be the last command in a command substitution</string>
					<key>match</key>
					<string>(begin)\s*(\))</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>begin(?=\s*$|\s*[\n;]|\s+[^\s-])</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>The begin command can be alone on a line or followed by any command that doesn't start with a '-'. If a '-' is seen it shouldn't be treated as a block</string>
					<key>end</key>
					<string>end(?=$|[\s);&amp;|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.begin.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=while\s+[^\s)#;-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=$|[\s);&amp;|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.while.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>while</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the command name we know is there, include a single instance of a pipeline, and end when an operator is seen</string>
							<key>end</key>
							<string>(?=[\n);&amp;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#pipeline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\n)|(;)|(?=[)&amp;])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen. Base scope handles any invalid operators</string>
							<key>end</key>
							<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=if\s+[^\s)#;-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=$|[\s);&amp;|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.if.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#command-call-standard-block-if-internal</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=for\s+[^\s)#;-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=$|[\s);&amp;|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.for-in.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(for)(\s+)</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the command name we know is there, include a single instance of a parameter (the varname), and end when the whitespace after the varname is captured</string>
							<key>end</key>
							<string>\s+</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#parameter</string>
								</dict>
								<dict>
									<key>comment</key>
									<string>Capture anything that a parameter explicitly rejects, which is mostly operators</string>
									<key>match</key>
									<string>\S+</string>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Line continuation is allowed between the varname and "in"</string>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>in(?=\s)</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the command name which might be there, include an arbitrary number of arguments, and end when the control operator is seen</string>
							<key>end</key>
							<string>(?=[\n)#;&amp;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#separator-whitespace</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\n)|(;)|(?=[)#&amp;])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen. Base scope handles any invalid operators</string>
							<key>end</key>
							<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything beside line continuation, "in", or a control operator is invalid</string>
							<key>match</key>
							<string>\S+?(?=[\s);&amp;])</string>
							<key>name</key>
							<string>invalid.illegal.function-call.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#separator-whitespace</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=switch\s+[^\s)#;-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=$|[\s);&amp;|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.switch.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?=switch)</string>
							<key>comment</key>
							<string>Anonymous scope - Match the valid part of the switch statement, then look for an invalid part</string>
							<key>end</key>
							<string>(?=[\n);&amp;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(switch)(\s+)</string>
									<key>beginCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Anonymous scope - Capture the command name we know is there, include a single instance of a parameter (the value), and end when whitespace or a control operator is seen</string>
									<key>end</key>
									<string>(?=[\s);&amp;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#parameter</string>
										</dict>
										<dict>
											<key>comment</key>
											<string>Capture anything that a parameter explicitly rejects, which is mostly operators</string>
											<key>match</key>
											<string>\S+</string>
											<key>name</key>
											<string>invalid.illegal.operator.fish</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>begin</key>
									<string>\s+</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Anonymous scope - Capture whitespace which might be there, match any non-control-operator strings as invalid, and end when a control operator is seen</string>
									<key>end</key>
									<string>(?=[\n);&amp;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>match</key>
											<string>\S+?(?=[\s);&amp;])</string>
											<key>name</key>
											<string>invalid.illegal.string.fish</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\n)|(;)|(?=[)&amp;])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen. Base scope handles any invalid operators</string>
							<key>end</key>
							<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>case(?=[\s);&amp;])</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Anonymous scope - Capture the command name which might be there, include an arbitrary number of arguments, and end when the control operator is captured. Base scope further down handles any invalid operators used to end the scope</string>
									<key>end</key>
									<string>(\n)|(;)|(?=[)#&amp;|]|(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)</string>
									<key>endCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.operator.control.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
										</dict>
									</dict>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#separator-whitespace</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#argument</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=function\s+[^\s)#;-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=$|[\s);&amp;|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?=function)</string>
							<key>comment</key>
							<string>Anonymous scope - Match the defined name of the function statement, then look for further parameters</string>
							<key>end</key>
							<string>(?x)
(?# Look ahead for operators)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;|]
  |
    (?# Find a redirect or pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)
  )
)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(function)\s+</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.name.fish</string>
										</dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>keyword.control.conditional.fish meta.string.unquoted.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Anonymous scope - Capture the command name we know is there, include a single instance of a parameter (the value), and end when whitespace or a control operator is seen</string>
									<key>end</key>
									<string>(?=[\s);&amp;|&lt;&gt;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>begin</key>
											<string>[|&lt;&gt;]</string>
											<key>end</key>
											<string>(?=[\s);&amp;])</string>
											<key>name</key>
											<string>invalid.illegal.string.fish</string>
										</dict>
										<dict>
											<key>begin</key>
											<string>(?!\\\n)</string>
											<key>comment</key>
											<string>Anonymous scope - Start when an escaped newline isn't present, and end when whitespace or an operator is seen</string>
											<key>end</key>
											<string>(?=[\s);&amp;|&lt;&gt;])</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>begin</key>
													<string>(?![\s)])</string>
													<key>comment</key>
													<string>This is all the usual things a parameter is allowed to contain</string>
													<key>end</key>
													<string>(?=[\s);&amp;|&lt;&gt;])</string>
													<key>name</key>
													<string>meta.function-call.parameter.argument.fish entity.name.function.fish</string>
													<key>patterns</key>
													<array>
														<dict>
															<key>include</key>
															<string>#parameter-patterns</string>
														</dict>
													</array>
												</dict>
											</array>
										</dict>
									</array>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?=[^\n\S])</string>
									<key>comment</key>
									<string>Anonymous scope - Capture whitespace which might be there, then match anything normal for a command call, except redirections!</string>
									<key>end</key>
									<string>(?x)
(?# Look ahead for operators)
(?=
  (?:
    (?# Find a control operator)
    [\n)#;&amp;|]
  |
    (?# Find a redirect or pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)
  )
)</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#separator-whitespace</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#parameter</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\n)|(;)|(?=[)#&amp;|]|(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen. Base scope handles any invalid operators</string>
							<key>end</key>
							<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-standard-block-if-internal</key>
		<dict>
			<key>comment</key>
			<string>The acceptable structure internal to an if-end block can be represented recursively because anonymous scopes nest silently. If an `else` without a following `if` is seen, then further `else` commands will be correctly marked as invalid. This is a lot of work just to get that extra little bit of functionality :)</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=if(?:\s*\n|\s+[^\s;]))</string>
					<key>comment</key>
					<string>Anonymous scope - Capture an `if` and the command up to the control operator, then capture from the control operator indefinitely</string>
					<key>end</key>
					<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>if</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Match the command name we know is there, include a single instance of a pipeline, and end when a control operator is seen</string>
							<key>end</key>
							<string>(?=[\n#;&amp;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#pipeline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(\n)|(;)|(?=[#&amp;])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Match the operator we know is there, then include the base scope or an `else` structure. Base scope handles any invalid operators</string>
							<key>end</key>
							<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?=else\s*[\s;])</string>
									<key>comment</key>
									<string>Anonymous scope - Capture an `else` up to the control operator or the start of an `if` structure, then match from the control operator indefinitely or match an `if` structure</string>
									<key>end</key>
									<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>begin</key>
											<string>else(?=\s*[\s;])</string>
											<key>beginCaptures</key>
											<dict>
												<key>0</key>
												<dict>
													<key>name</key>
													<string>meta.function-call.name.fish keyword.control.conditional.fish meta.string.unquoted.fish</string>
												</dict>
											</dict>
											<key>comment</key>
											<string>Anonymous scope - Match the `else` we know is there and any comment, and mark anything besides an `if` as illegal</string>
											<key>end</key>
											<string>(?=[\n#;&amp;]|if(?:\s*\n|\s+[^\s;]))</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>#separator-whitespace</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#line-continuation</string>
												</dict>
												<dict>
													<key>comment</key>
													<string>Anything else is illegal</string>
													<key>match</key>
													<string>\S+?(?=[\s;&amp;])</string>
													<key>name</key>
													<string>invalid.illegal.string.fish</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>begin</key>
											<string>(\n)|(;)|(?=[#&amp;])</string>
											<key>beginCaptures</key>
											<dict>
												<key>1</key>
												<dict>
													<key>name</key>
													<string>meta.function-call.operator.control.fish</string>
												</dict>
												<key>2</key>
												<dict>
													<key>name</key>
													<string>meta.function-call.operator.control.fish keyword.operator.control.fish</string>
												</dict>
											</dict>
											<key>comment</key>
											<string>Anonymous scope - Match the operator which will be there if no `if` was seen, then include the base scope which marks further `else` commands as invalid. Base scope handles any invalid operators</string>
											<key>end</key>
											<string>(?=end(?:$|[\s);&amp;|&lt;&gt;]))</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>$self</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>include</key>
											<string>#command-call-standard-block-if-internal</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-substitution</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\()</string>
					<key>comment</key>
					<string>Capture "(...)" or "(...)[...]"</string>
					<key>end</key>
					<string>(?![\(\[])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\(</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.parens.begin.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>\)</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.parens.end.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.parens.command-substitution.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>The inside of a command substitution is indistinguishable from a global scope</string>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#index-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>A full or inline comment outside of any command call</string>
					<key>end</key>
					<string>\n</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>index-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\[</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.brackets.begin.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>In other words, the anonymous scope which contains the variable and the index expansion parameter list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack. Our workaround is to allow an infinite number of these and hope the user can keep track of when there are too many</string>
					<key>end</key>
					<string>\]</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.brackets.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.brackets.index-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\.\.</string>
							<key>name</key>
							<string>keyword.operator.range.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>There's no need to apply meta.string.unquoted to anything inside of an index expansion, as if it needs to be applied then it would have been handled already. The fact index expansion can appear inside of quotes (after a variable expansion) makes it tricky to decide what is or isn't "unquoted"</string>
							<key>match</key>
							<string>(?:[+-]?[0-9]+)(?=[\s);&amp;|&lt;&gt;]|\]|\.\.)</string>
							<key>name</key>
							<string>constant.numeric.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything else is invalid</string>
							<key>match</key>
							<string>\S</string>
							<key>name</key>
							<string>invalid.illegal.index.fish</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>line-continuation</key>
		<dict>
			<key>comment</key>
			<string>This rule should be included anywhere that escaping a newline and adding an arbitrary number of comment lines is permitted (which is pretty much everywhere in fish)</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\\\n)</string>
					<key>comment</key>
					<string>End when an unescaped newline is seen, the first character of a line isn't whitespace or a comment character or the escaped newline itself, or if the next character after some consumed whitespace isn't more whitespace or a comment character</string>
					<key>end</key>
					<string>(?=\n)|^(?![\s\#\\])|\s(?![\s\#])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\\\n</string>
							<key>name</key>
							<string>constant.character.escape.newline</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>parameter</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?![\s);&amp;|&lt;&gt;^])</string>
					<key>comment</key>
					<string>See the argument rule for more general information on parameters</string>
					<key>end</key>
					<string>(?=[\s);&amp;|&lt;&gt;])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>End of options (parameter of just two hyphens)</string>
							<key>match</key>
							<string>(?:--)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.option.end.fish variable.parameter.fish punctuation.definition.option.end.fish meta.string.unquoted.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=--)</string>
							<key>comment</key>
							<string>Long option (parameter starting with two hyphens)</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.option.long.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?:--)</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>punctuation.definition.option.long.begin.fish meta.string.unquoted.fish</string>
										</dict>
									</dict>
									<key>end</key>
									<string>(?=[\s);&amp;|&lt;&gt;]|=)</string>
									<key>name</key>
									<string>variable.parameter.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#command-substitution</string>
										</dict>
										<dict>
											<key>begin</key>
											<string>(?=\$)</string>
											<key>end</key>
											<string>(?!\$)</string>
											<key>name</key>
											<string>meta.string.unquoted.fish</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>#variable-expansion</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>include</key>
											<string>#string-quoted</string>
										</dict>
										<dict>
											<key>begin</key>
											<string>(?!['"])</string>
											<key>end</key>
											<string>(?=[\s);&amp;(|&lt;&gt;'"$]|\=)</string>
											<key>name</key>
											<string>meta.string.unquoted.fish</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>#string-unquoted-patterns</string>
												</dict>
											</array>
										</dict>
									</array>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?:=)</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>variable.parameter.fish punctuation.definition.option.long.separator.fish meta.string.unquoted.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Consume the '=' and then use standard parameter patterns as well as numerics</string>
									<key>end</key>
									<string>(?=[\s);&amp;|&lt;&gt;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>match</key>
											<string>(?:[+-]?)(?:[0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)(?=$|[\s);&amp;|&lt;&gt;])</string>
											<key>name</key>
											<string>meta.string.unquoted.fish constant.numeric.fish</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#parameter-patterns</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?:-)(?=[^\s);&amp;|&lt;&gt;])</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.option.short.fish meta.string.unquoted.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Short option (parameter starting with one hyphen)</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.parameter.option.short.fish variable.parameter.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#parameter-patterns</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#argument</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>parameter-patterns</key>
		<dict>
			<key>comment</key>
			<string>The typical substitutions, expansions, and escapes allowed anywhere in a parameter</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#command-substitution</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\$)</string>
					<key>comment</key>
					<string>Give variable expansion the unquoted string scope, since if it appears inside a string it gets the quoted string scope and we should mirror that</string>
					<key>end</key>
					<string>(?!\$)</string>
					<key>name</key>
					<string>meta.string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>#string</string>
				</dict>
			</array>
		</dict>
		<key>pipeline</key>
		<dict>
			<key>comment</key>
			<string>The pipeline rule is nonterminating, meaning that it will not consume a *valid* control operator ('\n', ')', '#', ';', or '&amp;'). It *will* consume control operators that appear in invalid locations</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=(and|or)\b(?!\s*[\n)#;-]))</string>
					<key>comment</key>
					<string>If the command is followed by redirection, then the redirection is illegal so we have to open the scope and let it be caught by</string>
					<key>end</key>
					<string>(?=[\n)#;&amp;])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(and|or)\b(?!\s*[\n);-])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.name.fish keyword.operator.word.fish meta.string.unquoted.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>If the command is followed by an "&amp;", then that's invalid</string>
							<key>end</key>
							<string>(?![^\n\S]|\&amp;|\\\n)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#separator-whitespace</string>
								</dict>
								<dict>
									<key>match</key>
									<string>\&amp;</string>
									<key>name</key>
									<string>invalid.illegal.function-call.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#pipeline</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>#pipeline-segment</string>
				</dict>
			</array>
		</dict>
		<key>pipeline-segment</key>
		<dict>
			<key>comment</key>
			<string>The pipeline segment is agnostic of where it appears in the overall pipeline, but it does perform checks on what can appear after a pipe (if there is one) before it will recurse into itself</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=[&amp;|]|(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)</string>
					<key>comment</key>
					<string>Match operators (background, pipe, and redirect) which cannot start a pipeline because they must be consumed within or after a pipeline</string>
					<key>end</key>
					<string>(?x)
(?# Look ahead to ensure no more operators after whitespace)
(?=\n)
|
(?!
  \s*
  (?:
    (?# Find a control operator)
    [\n);&amp;|]
  |
    (?# Find a pipe operator)
    (?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?
  )
)</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>(?:[&amp;|]|(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)</string>
							<key>name</key>
							<string>invalid.illegal.function-call.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>comment</key>
					<string>Match a command which is illegal in the base scope</string>
					<key>match</key>
					<string>(?:case|else|end)(?=[\s);&amp;|&lt;&gt;])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=[^\s#])</string>
					<key>comment</key>
					<string>Anonymous scope - A pipeline which may be one command call or multiple command calls linked by pipe operators ('|', '2&gt;|', etc). The pipeline terminates at the first encounter of any control operator</string>
					<key>end</key>
					<string>(?=[\n)#;&amp;])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?x)
(?# Negative lookahead for whitespace, comments, piping)
(?!
  \s|\#|(?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
)</string>
							<key>comment</key>
							<string>Anonymous scope - Match the command of a pipeline segment</string>
							<key>end</key>
							<string>(?x)
(?# Look ahead for operators after whitespace)
(?=\s*
  (?:
    (?# Find a control operator)
    [\n)#;&amp;]
  |
    (?# Find a pipe operator)
    (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
  )
)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#command-call-meta</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-standard</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?x)
(?# Look ahead for piping)
(?=
  (?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|
)</string>
							<key>comment</key>
							<string>Anonymous scope - Match piping which may lead to a second command, and if it does recurse into</string>
							<key>end</key>
							<string>(?=[\n)#;&amp;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Check for a malformed pipeline segment; if the pipeline would end with a control operator (or a comment, which implies a newline), then mark the pipe itself invalid</string>
									<key>match</key>
									<string>(?:(?:[0-9]+)?(?:&lt;|&gt;&gt;?)|\^\^?)?\|(?=\s*(?:$|[\n)#;&amp;]))</string>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?:([0-9]+)?(&lt;|&gt;&gt;?)|(\^\^?))?(\|)</string>
									<key>captures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>meta.function-call.operator.pipe.fish</string>
										</dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>constant.numeric.file-descriptor.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.pipe.redirect.fish</string>
										</dict>
										<key>3</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.pipe.redirect.fish</string>
										</dict>
										<key>4</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.pipe.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Otherwise, we'll say the pipe is okay and let the tests at the start of</string>
									<key>end</key>
									<string>(?=[\n)#;&amp;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>comment</key>
											<string>This match should generally be pretty similar to the match which seeks a valid "and"/"or" in</string>
											<key>match</key>
											<string>(and|or)\b(?!\s*[\n;-])</string>
											<key>name</key>
											<string>invalid.illegal.function-call.fish</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#separator-whitespace</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#pipeline-segment</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>redirection</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=(?:[0-9]+(?:&lt;|&gt;&gt;|&gt;)|&gt;&gt;|\^\^|[&lt;&gt;^])\&amp;)</string>
					<key>comment</key>
					<string>End at anything that would end a parameter, including redirections *if* they are *not* this same type of redirection (ie, have an '&amp;'), in which case this scope stays open and we match the next one. The negative lookahead for &lt;&gt;^ at the end is to keep ST2 happy (not hanging)</string>
					<key>end</key>
					<string>(?=[\s);&amp;|]|(?:[0-9]+(?:&lt;|&gt;&gt;|&gt;)|&gt;&gt;|\^\^|[&lt;&gt;^])(?![&amp;&lt;&gt;^]))</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?:([0-9]+)(&lt;|&gt;&gt;|&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;^]))(\&amp;)\s*</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.redirection.fish</string>
								</dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.string.unquoted.fish constant.numeric.file-descriptor.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.redirect.fish</string>
								</dict>
								<key>3</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.redirect.fish</string>
								</dict>
								<key>4</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.redirect.dereference.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>We have to try and catch an '&amp;' here because if it is seen by the outer end match then it will be considered a valid operator and the redirection scope will immediately terminate</string>
							<key>end</key>
							<string>([#&amp;]\S*)|(?![&amp;\\])</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.redirection.fish</string>
								</dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>invalid.illegal.file-descriptor.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=\()</string>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>end</key>
							<string>(?!\()</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#command-substitution</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=\$)</string>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>end</key>
							<string>(?!\$)</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#variable-expansion</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=['"])</string>
							<key>comment</key>
							<string>May be a quoted integer, which is allowed</string>
							<key>end</key>
							<string>(?!['"])</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string-quoted</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[0-9]+)(?=$|[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.file-descriptor.fish meta.string.unquoted.fish constant.numeric.file-descriptor.fish</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:-)(?=$|[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.file-descriptor.fish meta.string.unquoted.fish keyword.operator.redirect.close.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything else is illegal</string>
							<key>match</key>
							<string>(?:\S+)</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish invalid.illegal.file-descriptor.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=(?:[0-9]+(?:&lt;|&gt;&gt;|&gt;)|&gt;&gt;|\^\^|[&lt;&gt;^])\??)</string>
					<key>comment</key>
					<string>End at anything that would end a parameter, including redirections *if* they are *not* this same type of redirection (ie, redirection into file descriptor, or into pipe), in which case this scope stays open and we match the next one</string>
					<key>end</key>
					<string>(?=[\s);&amp;|]|(?:[0-9]+(?:&lt;|&gt;&gt;|&gt;)|&gt;&gt;|\^\^|[&lt;&gt;^])[&amp;|])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?:([0-9]+)(&lt;|&gt;&gt;|&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;^]))(\?)?\s*</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.redirection.fish</string>
								</dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.string.unquoted.fish constant.numeric.file-descriptor.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.redirect.fish</string>
								</dict>
								<key>3</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.redirect.fish</string>
								</dict>
								<key>4</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.redirect.clobber-test.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>We have to try and catch bad operators here because if they are seen by the outer end match then they will be considered valid and the redirection scope will immediately terminate</string>
							<key>end</key>
							<string>((?:[#&amp;?]|[0-9]*[&lt;&gt;^])\S*)|(?![&amp;?&lt;&gt;^])</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.function-call.operator.redirection.fish</string>
								</dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>invalid.illegal.path.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\{|(?=\})</string>
							<key>comment</key>
							<string>A redirection path cannot contain brace expansion</string>
							<key>end</key>
							<string>[\s);&amp;|}]</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish invalid.illegal.path.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>A redirection path cannot contain wildcard expansion</string>
							<key>match</key>
							<string>[*?]</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish invalid.illegal.path.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Check for characters which are associated with redirection, so path cannot begin with them</string>
							<key>match</key>
							<string>(?:[&amp;?]|[0-9]*[&lt;&gt;^]).*$</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish invalid.illegal.path.fish</string>
						</dict>
						<dict>
							<key>match</key>
							<string>\~</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.path.fish meta.string.unquoted.fish keyword.operator.tilde.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?![\s);&amp;(|&lt;&gt;${}*?])</string>
							<key>comment</key>
							<string>Use strings to build a file path, but break out if any invalid elements or elements that wouldn't form a literal path are encountered</string>
							<key>end</key>
							<string>(?=[\s);&amp;(|&lt;&gt;${}*?])</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.path.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string-quoted</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?![\s);&amp;(|&lt;&gt;${}*?]|['"])</string>
									<key>comment</key>
									<string>Should use the same patterns as the above begin/end, but also add the quotes so the</string>
									<key>end</key>
									<string>(?=[\s);&amp;(|&lt;&gt;${}*?]|['"])</string>
									<key>name</key>
									<string>meta.string.unquoted.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#string-unquoted-patterns-escapes</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=\()</string>
							<key>comment</key>
							<string>A raw path cannot begin with '(' since this undergoes command substitution</string>
							<key>end</key>
							<string>(?!\()</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#command-substitution</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=\$)</string>
							<key>comment</key>
							<string>We also make sure that variable expansion is scoped as an unquoted string, since if it appears inside quotes then it gets scoped as a quoted string and we should mirror that</string>
							<key>end</key>
							<string>(?!\$)</string>
							<key>name</key>
							<string>meta.function-call.operator.redirection.fish meta.string.unquoted</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#variable-expansion</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>separator-whitespace</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Fundamental structure used to separate elements of a command call; it's any whitespace that isn't a newline, predominantly meaning spaces or tabs</string>
					<key>match</key>
					<string>(?:[^\n\S]+)</string>
					<key>name</key>
					<string>meta.function-call.fish</string>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#string-quoted</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string-unquoted</string>
				</dict>
			</array>
		</dict>
		<key>string-quoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \' and \\</string>
							<key>match</key>
							<string>\\[\'\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \&lt;newline&gt;, \", \\, and \$</string>
							<key>match</key>
							<string>\\[\n\"\\$]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Variable expansion is the only expansion accepted</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?![\s);&amp;(|&lt;&gt;'"$])</string>
					<key>comment</key>
					<string>End unquoted string at anything that can't be in one</string>
					<key>end</key>
					<string>(?=[\s);&amp;(|&lt;&gt;'"$])</string>
					<key>name</key>
					<string>meta.string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string-unquoted-patterns</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns</key>
		<dict>
			<key>comment</key>
			<string>Describe contents of an unquoted string separately for ease of recursion</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#string-unquoted-patterns-escapes</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.braces.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\})|(\n|[;&amp;)|].*)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.braces.end.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.punctuation.section.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.braces.brace-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\,</string>
							<key>name</key>
							<string>punctuation.section.braces.separator.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Unescaped spaces aren't allowed, as technically that separates the braces into two separate arguments. Don't consume a newline though, so the scope end capture can get it</string>
							<key>match</key>
							<string>(?:[^\n\S]+)</string>
							<key>name</key>
							<string>invalid.illegal.whitespace.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[+-]?)(?:[0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)(?=$|[\s);&amp;|&lt;&gt;]|\}|\,)</string>
							<key>name</key>
							<string>constant.numeric.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?![\s);&amp;|&lt;&gt;'"])</string>
							<key>comment</key>
							<string>Begin/end string as before with the addition of breaking at a '}' or ','</string>
							<key>end</key>
							<string>(?=[\s);&amp;|&lt;&gt;'"]|\}|\,)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>match</key>
									<string>\\\,</string>
									<key>name</key>
									<string>constant.character.escape.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.double-star.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.single-star.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.question-mark.fish</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\*\*)|(\*)|(\?)</string>
					<key>name</key>
					<string>meta.wildcard-expansion.fish</string>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns-escapes</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This list follows the order given in official fish documentation. Technically '~' and '%' only need escaping if they appear at the front of a parameter. If they are escaped within a parameter, then fish does not *highlight* the escape, however it does silently *parse* the escape and the backslash is removed before the parameter is passed to the command. So, we highlight these escapes as well since they are actually treated as valid escapes by fish</string>
					<key>match</key>
					<string>(?x)
\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;|;"']
|
\\[~%]
|
\\[xX][0-9A-Fa-f]{1,2}
|
\\[0-7]{1,3}
|
\\u[0-9A-Fa-f]{1,4}
|
\\U[0-9A-Fa-f]{1,8}
|
\\c[?-~]</string>
					<key>name</key>
					<string>constant.character.escape.fish</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string-unquoted-patterns-escapes-newline</string>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns-escapes-newline</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Just for convenience we separate the newline escape</string>
					<key>match</key>
					<string>\\\n</string>
					<key>name</key>
					<string>constant.character.escape.newline.fish</string>
				</dict>
			</array>
		</dict>
		<key>variable-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#variable-expansion-illegal</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\$)</string>
					<key>comment</key>
					<string>Capture "$foo" or "$foo[]" or "$$foo[][]" etc</string>
					<key>end</key>
					<string>(?=[^\$\[])</string>
					<key>name</key>
					<string>meta.variable-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#variable-expansion-simple</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#index-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable-expansion-illegal</key>
		<dict>
			<key>comment</key>
			<string>Describe illegal variable expansions separately</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted</string>
					<key>match</key>
					<string>\$(?:(?=[,'"\]}\s);&amp;|])|[^\w\$][^$,'"\]}\s);&amp;|]*)</string>
					<key>name</key>
					<string>invalid.illegal.variable-expansion.fish</string>
				</dict>
			</array>
		</dict>
		<key>variable-expansion-simple</key>
		<dict>
			<key>comment</key>
			<string>Describe variable expansion that has no index expansion separately</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\$</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.variable.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?=[^\$\w])(?!\\\n)</string>
					<key>name</key>
					<string>variable.other.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string-unquoted-patterns-escapes-newline</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion-illegal</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion-simple</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.shell.fish</string>
	<key>uuid</key>
	<string>f9278d07-f7c1-4a9b-9581-ebcbc050fbfb</string>
</dict>
</plist>
