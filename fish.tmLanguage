<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>fish</string>
	</array>
	<key>firstLineMatch</key>
	<string>^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-</string>
	<key>foldingStartMarker</key>
	<string>\b(begin|case|for|if|else|function|switch|while)\b|(\{)$</string>
	<key>foldingStopMarker</key>
	<string>^\s*(\}|(case|else|end)\b)</string>
	<key>keyEquivalent</key>
	<string>^~S</string>
	<key>name</key>
	<string>Shell Script Improved (fish)</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>comment</key>
			<string>Base scope - Pick up '#' and "\\\n" before command-call sees them</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comment-external</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#line-continuation</string>
		</dict>
		<dict>
			<key>begin</key>
			<string>\)</string>
			<key>comment</key>
			<string>In an ideal world, command-call-standard would be performing this match because fish highlights the strings which follow as arguments. But we can't do that</string>
			<key>end</key>
			<string>(?=[\s;&amp;)|&lt;&gt;])</string>
			<key>name</key>
			<string>meta.function-call.fish invalid.illegal.function-call.fish</string>
		</dict>
		<dict>
			<key>begin</key>
			<string>(?=\S)</string>
			<key>comment</key>
			<string>Anonymous scope - Base scope command chain (up until a newline or ';')</string>
			<key>end</key>
			<string>\n|(;)|(?=\))</string>
			<key>endCaptures</key>
			<dict>
				<key>1</key>
				<dict>
					<key>name</key>
					<string>meta.function-call.operator.fish keyword.operator.fish</string>
				</dict>
			</dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Match an operation which cannot start a command chain (because it is consumed by the command chain when it appears further within it). These are simple control operators and redirections (which conveniently also matches redirection-into-pipe)</string>
					<key>match</key>
					<string>(?:[&amp;|]|(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))</string>
					<key>name</key>
					<string>invalid.illegal.operator.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\S)</string>
					<key>comment</key>
					<string>The reason we match the '&amp;' in a different way is the ';' can be alone on a line, while we must explicitly require that the '&amp;' comes after a command</string>
					<key>end</key>
					<string>(?=[\n;)])|(&amp;)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.operator.fish keyword.operator.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#command-chain</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>argument</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?![\s;&amp;)|&lt;&gt;^])</string>
					<key>comment</key>
					<string>End arg if it precedes whitespace or control operators (including stdin/stdout redirection but not stderr due to a fish quirk), or an escaped newline (which line-continuation should take care of)</string>
					<key>end</key>
					<string>(?=[\s;&amp;)|&lt;&gt;])|(?=\\\n)</string>
					<key>name</key>
					<string>meta.argument.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Home directory expansion only occurs if the '~' is at the front of the argument</string>
							<key>match</key>
							<string>\~</string>
							<key>name</key>
							<string>meta.string.unquoted.fish meta.home-directory-expansion.fish keyword.operator.tilde.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\%</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>meta.string.unquoted.fish punctuation.definition.process.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Process expansion only occurs if the '%' is at the front of the argument, and continues for the entire argument</string>
							<key>end</key>
							<string>(?=[\s;&amp;)|&lt;&gt;])</string>
							<key>name</key>
							<string>meta.process-expansion.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Match special process names. By a convention that I'm making up, scope them as a type of variable</string>
									<key>match</key>
									<string>(?:self|last)(?=[\s;&amp;)|])</string>
									<key>name</key>
									<string>meta.string.unquoted.fish variable.language.fish</string>
								</dict>
								<dict>
									<key>comment</key>
									<string>An escaped newline during a process expansion cannot be used to insert comments so consume it and let the process expansion continue on the next line</string>
									<key>match</key>
									<string>\\\n</string>
									<key>name</key>
									<string>constant.character.escape.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-substitution</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#variable-expansion</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?!\s)</string>
							<key>comment</key>
							<string>Arguments are otherwise made of strings, either quoted or unquoted. The unquoted string rule handles numerics, character escapes, command substitutions, and brace/variable/process expansions. These scopes consume the remainder of the argument</string>
							<key>end</key>
							<string>(?=[\s;&amp;)|&lt;&gt;])|(?=\\\n)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#command-substitution</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?=\$)</string>
									<key>comment</key>
									<string>Give the variable expansion the unquoted string scope</string>
									<key>end</key>
									<string>(?!\$)</string>
									<key>name</key>
									<string>meta.string.unquoted.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#variable-expansion</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-block</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(switch)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*([;&amp;]))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.switch.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=switch)</string>
							<key>comment</key>
							<string>Value ends at a newline or ';'</string>
							<key>end</key>
							<string>\n|(;)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.block.switch.value.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(case)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Case block ends before a new case or the end of the switch block</string>
							<key>end</key>
							<string>(?=\b(case|end)\b)</string>
							<key>name</key>
							<string>meta.block.switch.case.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=case)</string>
									<key>comment</key>
									<string>Wildcard ends at a newline or ';'</string>
									<key>end</key>
									<string>\n|(;)</string>
									<key>endCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.fish</string>
										</dict>
									</dict>
									<key>name</key>
									<string>meta.block.switch.case.wildcard.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-internal-end</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#argument</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-external</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(function)\b(?!\s+(&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*([;&amp;]))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=function)</string>
							<key>comment</key>
							<string>Name and options end at a newline or ';'</string>
							<key>end</key>
							<string>\n|(;)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=function)\s+</string>
									<key>comment</key>
									<string>Detect the region from just after the `function` command to between the defined function name and the argument or control operators which follow it. Note that we have to account for the fact the defined function name may end in an escaped space</string>
									<key>end</key>
									<string>(?&lt;=\S|\\ )\s*(?=[\S\n;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>comment</key>
											<string>The function name may be given using any means that is valid for a command call</string>
											<key>match</key>
											<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
											<key>name</key>
											<string>entity.name.function.fish</string>
										</dict>
										<dict>
											<key>comment</key>
											<string>We can't read across lines, so this is needed to catch an escaped newline at the begin of a defined function name</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-internal-end</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>comment</key>
									<string>The rest of the patterns are the typical elements of a standard command-call, which is what the `function` command adheres to</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(return)\b(?!\s+(-))</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The `return` command can't accept flags</string>
							<key>end</key>
							<string>(?=\)|;)|\n|(&amp;|\|)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-block-if-internal</key>
		<dict>
			<key>comment</key>
			<string>The acceptable structure internal to an if-end block can be represented recursively because anonymous scopes nest silently. If an `else` without a following `if` is seen, then further `else` commands will be correctly marked as invalid. This is a lot of work just to get that extra little bit of functionality :)</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=if(?:\s*\n|\s+[^\s;]))</string>
					<key>comment</key>
					<string>Anonymous scope - Capture an `if` and the command up to the end-of-scope operator, then capture from the end-of-scope operator indefinitely</string>
					<key>end</key>
					<string>(?=end[\s;&amp;)|&lt;&gt;])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>if</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Match the command name we know is there, include a single instance of a command chain, and end when an operator is seen</string>
							<key>end</key>
							<string>\s*(?=[\n;&amp;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-chain</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\n|(;)|(&amp;)</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Match the operator we know is there, then include the base scope or an `else` structure</string>
							<key>end</key>
							<string>(?=end[\s;&amp;)|&lt;&gt;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?=else\s*[\s;])</string>
									<key>comment</key>
									<string>Anonymous scope - Capture an `else` up to the end-of-scope operator or the start of an `if` structure, then match from the end-of-scope operator indefinitely or match an `if` structure</string>
									<key>end</key>
									<string>(?=end[\s;&amp;)|&lt;&gt;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>begin</key>
											<string>else(?=\s*[\s;])</string>
											<key>beginCaptures</key>
											<dict>
												<key>0</key>
												<dict>
													<key>name</key>
													<string>keyword.control.conditional.fish</string>
												</dict>
											</dict>
											<key>comment</key>
											<string>Anonymous scope - Match the `else` we know is there and any comment, and mark anything besides an `if` as illegal</string>
											<key>end</key>
											<string>\s*(?=[\n;&amp;]|if(?:\s*\n|\s+[^\s;]))</string>
											<key>endCaptures</key>
											<dict>
												<key>1</key>
												<dict>
													<key>name</key>
													<string>keyword.operator.fish</string>
												</dict>
												<key>2</key>
												<dict>
													<key>name</key>
													<string>invalid.illegal.operator.fish</string>
												</dict>
											</dict>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>#line-continuation</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#comment-internal-end</string>
												</dict>
												<dict>
													<key>comment</key>
													<string>Anything else is illegal</string>
													<key>match</key>
													<string>(?:\S+?(?=[\s;&amp;]))</string>
													<key>name</key>
													<string>invalid.illegal.function-call.fish</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>begin</key>
											<string>\n|(;)|(&amp;)</string>
											<key>beginCaptures</key>
											<dict>
												<key>1</key>
												<dict>
													<key>name</key>
													<string>keyword.operator.fish</string>
												</dict>
												<key>2</key>
												<dict>
													<key>name</key>
													<string>invalid.illegal.operator.fish</string>
												</dict>
											</dict>
											<key>comment</key>
											<string>Anonymous scope - Match the operator which will be there if no `if` was seen, then include the base scope which marks further `else` commands as invalid</string>
											<key>end</key>
											<string>(?=end[\s;&amp;)|&lt;&gt;])</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>include</key>
													<string>$self</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>comment</key>
											<string>Match the `if` structure which will be there if no operator was seen</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#command-call-block-if-internal</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-block-rewrite</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.function.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.operator.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Block commands cannot be backgrounded, piped, or redirected</string>
					<key>match</key>
					<string>(begin|while|if|for)\s*([&amp;|&lt;&gt;])</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.function.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.operator.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>The begin command uniquely cannot be the last command in a command substitution</string>
					<key>match</key>
					<string>(begin)\s*(\))</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>begin(?=\s*[\n;]|\s+[^\s-])</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>The begin command can be alone on a line or followed by any command that doesn't start with a '-'. If a '-' is seen it shouldn't be treated as a block</string>
					<key>end</key>
					<string>end(?=[\s;&amp;)|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.begin.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=while\s+[^\s;)-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=[\s;&amp;)|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.while.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>while</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the command name we know is there, include a single instance of a command chain, and end when an operator is seen</string>
							<key>end</key>
							<string>\s*(?=[\n;&amp;)])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-chain</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\n|(;)|([&amp;)])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen</string>
							<key>end</key>
							<string>(?=end[\s;&amp;)|&lt;&gt;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=if\s+[^\s;)-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=[\s;&amp;)|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.if.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Note that this internal scope does not treat the closing parenthesis as an operator, because a command substitution can't end in the middle of a block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-block-if-internal</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=for\s+[^\s;)-])</string>
					<key>comment</key>
					<string>If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope</string>
					<key>end</key>
					<string>end(?=[\s;&amp;)|&lt;&gt;])</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.for-in.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(for)(?:\s+)</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the command name we know is there, include a single instance of an argument (the varname), and end when the whitespace after the varname is captured</string>
							<key>end</key>
							<string>\s+</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>comment</key>
									<string>Capture anything that an argument explicitly rejects, which is mostly operators</string>
									<key>match</key>
									<string>\S+</string>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Line continuation is allowed between the varname and "in"</string>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>in(?=\s)</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the command name which might be there, include an arbitrary number of arguments, and end when the control operator is seen</string>
							<key>end</key>
							<string>\s*(?=[\n;&amp;)])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\n|(;)|([&amp;)])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen</string>
							<key>end</key>
							<string>(?=end[\s;&amp;)|&lt;&gt;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything beside line continuation, "in", or a control operator is invalid</string>
							<key>match</key>
							<string>\S+?(?=[\s;&amp;])</string>
							<key>name</key>
							<string>invalid.illegal.function-call.fish</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-meta</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(builtin|command|exec)\b(?!\s+[-&amp;|])</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Check if the command is a builtin which takes another command as arguments, ie, a meta command. Because these commands could take options or be backgrounded/piped -- in which case they do not behave as meta commands -- look ahead to ensure that no options or control operators are found. Note also that a meta command forces its argument to behave as a standard command</string>
					<key>end</key>
					<string>(?=[\n;&amp;)|])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-standard</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-standard</key>
		<dict>
			<key>comment</key>
			<string>Check if the command is any other legal command, ie, a standard command</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>comment</key>
					<string>A command call can't be a comment, but this match will only be satisfied if the command is first after a pipe because comments are otherwise consumed earlier</string>
					<key>end</key>
					<string>(?=[\n)])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Match an operator which cannot start a command call but does not stop the next characters from being interpreted as a command</string>
					<key>match</key>
					<string>(?:[&amp;|&lt;&gt;^])</string>
					<key>name</key>
					<string>invalid.illegal.operator.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\S)</string>
					<key>comment</key>
					<string>Anonymous scope - A complete command comprising a name element and optional argument, redirection, and comment elements</string>
					<key>end</key>
					<string>(?x)
(?# Look ahead for control operations)
(?=
  (?:
    (?# Find control operations)
    [\n;&amp;)]
  |
    (?# Find piping)
    (?:(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))?\|
  )
)</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?![\s&lt;&gt;^%])</string>
							<key>comment</key>
							<string>Anonymous scope - A name or block element. If a block is found, everything up to the `end` command is captured here. Note that redirection and process expansion can't start the element</string>
							<key>end</key>
							<string>(?=[\s;&amp;)|&lt;&gt;])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Look for block structures</string>
									<key>include</key>
									<string>#command-call-block-rewrite</string>
								</dict>
								<dict>
									<key>captures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>keyword.control.conditional.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>Look for loop control commands, which cannot take arguments. Unfortunately, without an effective scope stack we cannot restrict them to only be valid inside of loop constructs</string>
									<key>match</key>
									<string>(?:break|continue)(?=\s+[^\s-\w]|\s*[\n;&amp;)|&lt;&gt;])</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>(?!\s)</string>
									<key>comment</key>
									<string>Anonymous scope - A generic name element</string>
									<key>end</key>
									<string>(?=[\s;&amp;)|&lt;&gt;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>begin</key>
											<string>(?=\()</string>
											<key>comment</key>
											<string>fish would match the whole command name invalid if there was a command substitution anywhere in it, but we can't look ahead that effectively</string>
											<key>end</key>
											<string>(?=[\s;&amp;)|&lt;&gt;])</string>
											<key>name</key>
											<string>invalid.illegal.function-call.fish</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>begin</key>
													<string>\(</string>
													<key>end</key>
													<string>\)|(?=[\n;&amp;)|&lt;&gt;])</string>
												</dict>
											</array>
										</dict>
										<dict>
											<key>comment</key>
											<string>Match an escaped newline in the command name, but don't use line-continuation because comments aren't allowed</string>
											<key>match</key>
											<string>\\\n</string>
											<key>name</key>
											<string>constant.character.escape.fish</string>
										</dict>
										<dict>
											<key>begin</key>
											<string>(?!\s)</string>
											<key>comment</key>
											<string>Otherwise, treat the element as a fraction of a name made of arbitrary strings (which breaks at an escaped newline)</string>
											<key>end</key>
											<string>(?=[\s;&amp;()|&lt;&gt;]|\\\n)</string>
											<key>name</key>
											<string>variable.function.fish</string>
											<key>patterns</key>
											<array>
												<dict>
													<key>comment</key>
													<string>The string scope explicitly forbids '$' so that the argument rule can pick it up as a variable expansion, but '$' is treated as a literal in command names, so we have to match it separately</string>
													<key>match</key>
													<string>\$</string>
													<key>name</key>
													<string>meta.string.unquoted.fish</string>
												</dict>
												<dict>
													<key>include</key>
													<string>#string</string>
												</dict>
											</array>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\%</string>
							<key>comment</key>
							<string>A command name can't begin with a process expansion operator (however the variable expansion operator '$' is allowed)</string>
							<key>end</key>
							<string>(?=[\s;&amp;)|&lt;&gt;])</string>
							<key>name</key>
							<string>invalid.illegal.function-call.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Redirection can immediately follow the command name, without whitespace separation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#redirection</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?:[^\n\S]+)</string>
							<key>comment</key>
							<string>Match any whitespace character that isn't the newline</string>
							<key>end</key>
							<string>(?x)
(?# Look ahead for control operations)
(?=
  (?:
    (?# Find whitespace or simple control operations)
    [\s;&amp;)]
  |
    (?# Find piping)
    (?:(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))?\|
  )
)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#redirection</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-chain</key>
		<dict>
			<key>comment</key>
			<string>The command-chain rule is nonterminating, meaning that it will not consume a newline, ';', or '&amp;'</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Todo - Restructure command-chain so that this match isn't duplicated from the base scope. Might require the unary operator commands to become an explicit recursive match (though we tried this once and it was more complicated than anything should be)</string>
					<key>match</key>
					<string>(?:[&amp;|]|(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))</string>
					<key>name</key>
					<string>invalid.illegal.operator.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Match a command which acts as a unary operator on the command to the right. Neglect the match if it is taking the one valid option argument these commands accept. Allow the match if there is a scope-ending operation after the command name</string>
					<key>match</key>
					<string>(and|not|or)(?=\s+(?!-h|--help)|[;&amp;)|&lt;&gt;])</string>
					<key>name</key>
					<string>meta.function-call.fish keyword.operator.word.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Match a command which is illegal in the base scope</string>
					<key>match</key>
					<string>(?:case|else|end)(?=[\s;&amp;)|&lt;&gt;])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=[^\s#])</string>
					<key>comment</key>
					<string>Anonymous scope - Command chain. Define a command chain as either one command call, or multiple command calls linked by piping ('|', '2&gt;|', etc). The chain terminates at the first encounter of any other control operator (newline, ';', '&amp;') or the implied newline of the closing parenthesis of a command substitution</string>
					<key>end</key>
					<string>(\s*)(?=[\n;&amp;)])</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?=\S)</string>
							<key>comment</key>
							<string>Match one command, which may start with any non-whitespace character. If it starts with piping however, perform checks to ensure it is valid. A command call ends at any control operation including piping</string>
							<key>end</key>
							<string>(?x)
(?# Look ahead for control operations after whitespace)
(?=\s*
  (?:
    (?# Find simple control operations)
    [\n;&amp;)]
  |
    (?# Find piping)
    (?:(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))?\|
  )
)</string>
							<key>name</key>
							<string>meta.function-call.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>We can't lookahead to find a close parenthesis because we want that close parenthesis to be caught and marked invalid. The downside is that this means a pipe at the end of the inside of a command substitution will not be marked invalid, but it turns out the fish parser doesn't do that either!</string>
									<key>match</key>
									<string>(?:(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))?\|(?=\s*\n)</string>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
								<dict>
									<key>captures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>meta.pipe.fish constant.numeric.file-descriptor.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>meta.pipe.fish keyword.operator.redirect.fish</string>
										</dict>
										<key>3</key>
										<dict>
											<key>name</key>
											<string>meta.pipe.fish keyword.operator.pipe.fish</string>
										</dict>
										<key>4</key>
										<dict>
											<key>name</key>
											<string>invalid.illegal.function-call.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>If there's no command call after the pipe and the command chain would end with an operator, then mark the next control operator (and beyond) as invalid</string>
									<key>match</key>
									<string>(?x)
(?# Consume valid piping; groups 1 2 3)
(?:([0-9]+)?(&lt;|&gt;|&gt;&gt;))?(\|)
(?# Consume whitespace)
\s*
(?# Look ahead for control operations)
(?=
  (?:
    (?# Find simple control operations)
    [;&amp;]
  |
    (?# Find piping)
    (?:(?:[0-9]+)?(?:&lt;|&gt;|&gt;&gt;))?\|
  )
)
(?# Consume control operations and beyond; group 4)
(.*)$</string>
								</dict>
								<dict>
									<key>captures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>constant.numeric.file-descriptor.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.redirect.fish</string>
										</dict>
										<key>3</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.pipe.fish</string>
										</dict>
									</dict>
									<key>match</key>
									<string>(?:([0-9]+)?(&lt;|&gt;|&gt;&gt;))?(\|)</string>
									<key>name</key>
									<string>meta.pipe.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-meta</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-block</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-standard</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>comment</key>
					<string>Pick up a comment that comes after an '&amp;' or otherwise sneaks into the scope</string>
					<key>include</key>
					<string>#comment-internal-end</string>
				</dict>
			</array>
		</dict>
		<key>command-substitution</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\()</string>
					<key>comment</key>
					<string>Capture "(...)" or "(...)[...]"</string>
					<key>end</key>
					<string>(?&lt;=\))(?!\[)|(?&lt;=\])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\(</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.parens.begin.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>\)</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.parens.end.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.parens.command-substitution.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>The inside of a command substitution is indistinguishable from a global scope</string>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#index-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>comment-external</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>A full or inline comment outside of any command call</string>
					<key>end</key>
					<string>\n</string>
					<key>name</key>
					<string>comment.line.external.fish</string>
				</dict>
			</array>
		</dict>
		<key>comment-internal-end</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>An inline comment at the end of a command call. Does not consume the newline, thus allowing the command call to capture it and end</string>
					<key>end</key>
					<string>(?=\n)</string>
					<key>name</key>
					<string>comment.line.internal.end.fish</string>
				</dict>
			</array>
		</dict>
		<key>index-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\[</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.brackets.begin.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>In other words, the anonymous scope which contains the variable and the index expansion argument list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack. Our workaround is to allow an infinite number of these and hope the user can keep track of when there are too many</string>
					<key>end</key>
					<string>\]</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.brackets.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.brackets.index-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\.\.</string>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Manually recreate the</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[0-9]+)(?=[\s;&amp;)|&lt;&gt;'"]|\]|\.\.)</string>
							<key>name</key>
							<string>constant.numeric.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?![\s'"]|\.\.)</string>
							<key>comment</key>
							<string>Begin/end string as before with the addition of breaking at a ']' or ".."</string>
							<key>end</key>
							<string>(?=[\s;&amp;)|&lt;&gt;'"]|\]|\.\.)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>line-continuation</key>
		<dict>
			<key>comment</key>
			<string>This rule should be included anywhere that escaping a newline and adding an arbitrary number of comment lines is permitted (which is pretty much everywhere in fish)</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\\\n)</string>
					<key>comment</key>
					<string>End when the first character of a line isn't whitespace or a comment character, or if the next character after some consumed whitespace isn't more whitespace or a comment character</string>
					<key>end</key>
					<string>^(?![\s\#])|\s(?![\s\#])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\\\n</string>
							<key>name</key>
							<string>constant.character.escape</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\#</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.comment.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>\n</string>
							<key>name</key>
							<string>comment.line.continuation.fish</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>redirection</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?:([0-9]+)(&lt;|&gt;|&gt;&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;]|(?&lt;=^|\s)\^))(\&amp;)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirect.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirect.fish</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirect.dereference.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the integer found before the end match</string>
					<key>end</key>
					<string>(?&lt;=[^&amp;\s]|\n)(?=[\s);&amp;|&lt;&gt;])</string>
					<key>name</key>
					<string>meta.redirection.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[0-9]+)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:-)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>keyword.operator.redirect.close.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything else is illegal</string>
							<key>match</key>
							<string>(?:\S+.*)$</string>
							<key>name</key>
							<string>invalid.illegal.file-descriptor.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?:([0-9]+)(&lt;|&gt;|&gt;&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;]|(?&lt;=^|\s)\^))(\?)?</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirect.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirect.fish</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirect.clobber-test.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the path found before the end match</string>
					<key>end</key>
					<string>(?&lt;=[^&lt;&gt;^?\s]|\n)(?=[\s);&amp;|&lt;&gt;])|(?=\n)</string>
					<key>name</key>
					<string>meta.redirection.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string so path cannot begin with '('</string>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string so path cannot begin with '$'</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Check for characters which are associated with redirection, so path cannot begin with them</string>
							<key>match</key>
							<string>(?:(?:[&amp;?]|[0-9]*[&lt;&gt;^]).*)$</string>
							<key>name</key>
							<string>invalid.illegal.path.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Use the function call match to build a file path, as the syntax is fairly similar (possibly identical, with exceptions caught above)</string>
							<key>match</key>
							<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
							<key>name</key>
							<string>meta.path.fish</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#string-quoted</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string-unquoted</string>
				</dict>
			</array>
		</dict>
		<key>string-quoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \' and \\</string>
							<key>match</key>
							<string>\\[\'\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \&lt;newline&gt;, \", \\, and \$</string>
							<key>match</key>
							<string>\\[\n\"\\$]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Variable expansion is the only expansion accepted</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Treat a sequence of integers (with possible decimal separator) as a standalone constant. Do this separate to string-unquoted-pattens so we can ensure it is a string solely of numbers</string>
					<key>match</key>
					<string>(?:[0-9\.]+)(?=[\s;&amp;)|&lt;&gt;'"])</string>
					<key>name</key>
					<string>meta.string.unquoted.fish constant.numeric.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?!['"])</string>
					<key>comment</key>
					<string>End unquoted string at whitespace, control operators, quoted strings, a variable expansion, or an upcoming escaped newline</string>
					<key>end</key>
					<string>(?=[\s;&amp;()|&lt;&gt;'"$])|(?=\\\n)</string>
					<key>name</key>
					<string>meta.string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string-unquoted-patterns</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns</key>
		<dict>
			<key>comment</key>
			<string>Describe contents of an unquoted string separately for ease of recursion</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This list follows the order given in official fish documentation, with the addition of additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument</string>
					<key>match</key>
					<string>(?x)
\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;|;"']
|
(?&lt;=^|\s)\\[~%]
|
\\[xX][0-9A-Fa-f]{1,2}
|
\\[0-7]{1,3}
|
\\u[0-9A-Fa-f]{1,4}
|
\\U[0-9A-Fa-f]{1,8}
|
\\c[?-~]</string>
					<key>name</key>
					<string>constant.character.escape.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.braces.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\}</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.braces.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.braces.brace-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\,</string>
							<key>name</key>
							<string>punctuation.section.braces.separator.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Manually recreate the</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[0-9\.]+)(?=[\s;&amp;)|&lt;&gt;'"]|\}|\,)</string>
							<key>name</key>
							<string>constant.numeric.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?![\s'"])</string>
							<key>comment</key>
							<string>Begin/end string as before with the addition of breaking at a '}' or ','</string>
							<key>end</key>
							<string>(?=[\s;&amp;)|&lt;&gt;'"]|\}|\,)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>match</key>
									<string>\\\,</string>
									<key>name</key>
									<string>constant.character.escape.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.double-star.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.single-star.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.question-mark.fish</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\*\*)|(\*)|(\?)</string>
					<key>name</key>
					<string>meta.wildcard-expansion.fish</string>
				</dict>
			</array>
		</dict>
		<key>variable-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#variable-expansion-illegal</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\$)</string>
					<key>comment</key>
					<string>Capture "$foo" or "$foo[]" or "$$foo[][]" etc</string>
					<key>end</key>
					<string>(?&lt;=[\$\w])(?=[^\$\w\[])|(?&lt;=\])(?!\[)</string>
					<key>name</key>
					<string>meta.variable-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Match any depth of recursive variable expansions</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\$</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.variable.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?&lt;=[\$\w])(?=[^\$\w])</string>
							<key>name</key>
							<string>variable.other.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#variable-expansion-illegal</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#variable-expansion-simple</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>comment</key>
							<string>Match any number of consecutive index expansions</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#index-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable-expansion-illegal</key>
		<dict>
			<key>comment</key>
			<string>Describe illegal variable expansions separately</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted</string>
					<key>match</key>
					<string>\$(?:(?=[,'"\]}\s);&amp;|])|[^\w\$][^$,'"\]}\s);&amp;|]*)</string>
					<key>name</key>
					<string>invalid.illegal.variable-expansion.fish</string>
				</dict>
			</array>
		</dict>
		<key>variable-expansion-simple</key>
		<dict>
			<key>comment</key>
			<string>Describe variable expansion that has no index expansion separately</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\$</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.variable.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=[\$\w])(?=[^\$\w])</string>
					<key>name</key>
					<string>variable.other.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#variable-expansion-illegal</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion-simple</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.fish</string>
	<key>uuid</key>
	<string>f9278d07-f7c1-4a9b-9581-ebcbc050fbfb</string>
</dict>
</plist>
