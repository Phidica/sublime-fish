<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>fish</string>
	</array>
	<key>firstLineMatch</key>
	<string>^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-</string>
	<key>foldingStartMarker</key>
	<string>\b(begin|case|for|if|else|function|switch|while)\b|(\{)$</string>
	<key>foldingStopMarker</key>
	<string>^\s*(\}|(case|else|end)\b)</string>
	<key>keyEquivalent</key>
	<string>^~S</string>
	<key>name</key>
	<string>Shell Script Improved (fish)</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>comment</key>
			<string>These are the patterns which can appear in the base scope</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#block</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#command-call</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comment</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#control-operator</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#line-continuation</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>argument</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=^|\s)(?!\s|#|$)</string>
					<key>comment</key>
					<string>End arg if it precedes whitespace, unescaped control operators, or a newline. Note fish quirk; the stderr redirection operator '^' does not terminate an arg</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\s|\)|[;&amp;|&lt;&gt;]|$)</string>
					<key>name</key>
					<string>meta.function-call.argument.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Arguments are made of strings, either quoted or unquoted. The unquoted string rule handles numerics, character escapes, command substitutions, and brace/variable/process expansions</string>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>block</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(begin)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.begin.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(while)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.while.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(if)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.if.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call</string>
							<key>match</key>
							<string>\b(else(\s*if)?)\b</string>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(for)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.for-in.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=for)</string>
							<key>end</key>
							<string>(?&lt;=\w)(?=\W)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Treat the varname like an argument</string>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(in)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Treat the list as arguments</string>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(switch)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.switch.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=switch)</string>
							<key>comment</key>
							<string>Value ends before ';' or at a newline</string>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>name</key>
							<string>meta.block.switch.value.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(case)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Case block ends before a new case or the end of the switch block</string>
							<key>end</key>
							<string>(?=\b(case|end)\b)</string>
							<key>name</key>
							<string>meta.block.switch.case.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=case)</string>
									<key>comment</key>
									<string>Wildcard ends before ';' or at a newline</string>
									<key>end</key>
									<string>(?=;)|\n</string>
									<key>name</key>
									<string>meta.block.switch.case.wildcard.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#argument</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-inline</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#control-operator</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(function)\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*(&amp;))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=function)</string>
							<key>comment</key>
							<string>Name and options end before ';' or at a newline</string>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=function)\s+</string>
									<key>comment</key>
									<string>Detect the region from just after the `function` command to between the defined function name the argument or control operators which follow it. Note that we have to account for the fact the defined function name may end in an escaped space</string>
									<key>end</key>
									<string>(?&lt;=\S|\\ )\s*(?=\S|;|\n)</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>comment</key>
											<string>The function name may be given using any means that is valid for a command call</string>
											<key>match</key>
											<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
											<key>name</key>
											<string>entity.name.function.fish</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-inline</string>
										</dict>
										<dict>
											<key>comment</key>
											<string>We can't read across lines, so this is needed to catch an escaped newline at the start of a defined function name</string>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>comment</key>
									<string>The rest of the patterns are the typical elements of a standard command-call, which is what the `function` command adheres to</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(return)\b(?!\s+(-))</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The `return` command can't accept flags</string>
							<key>end</key>
							<string>(?=\)|;)|\n|(&amp;|\|)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-inline</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b((builtin|command|exec)|(and|not|or))\b(?!\s+(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>support.function.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Recursive command-call ends before ')' or ';', and just after a newline, '&amp;', or '|'. Standard command-call will have consumed the '&amp;' or '|'. Unfortunately, we cannot help but end after any newline we encounter, as the standard command-call only ends when it consumes a newline (allowing us to insert comments by having the comment consume its newline and prevent command-call matching it) and we cannot distinguish between a newline that was consumed by a command and a newline that was consumed by a comment. Put simply, this means that when a recursive command-call reaches a newline before its first standard command-call, the scope ends and the standard command-call on the next line loses the recursive command-call scope</string>
					<key>end</key>
					<string>(?=\)|;)|(?&lt;=\n|&amp;|\|)</string>
					<key>name</key>
					<string>meta.function-call.recursive.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>comment</key>
					<string>Search for illegal commands; these aren't valid outside of their use in blocks</string>
					<key>match</key>
					<string>\b(?:case|else|end)\b.*$\n?</string>
					<key>name</key>
					<string>invalid.illegal.function.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Search for illegal operators; these aren't allowed to start a command, but can appear unescaped later within it</string>
					<key>match</key>
					<string>(?&lt;=^|[(;&amp;|\s])[%^].*$\n?</string>
					<key>name</key>
					<string>invalid.illegal.operator.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>variable.function.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Command call ends before ')' or ';', and at a newline, '&amp;', or '|'. Those last two control operators must be part of a command, so consume them here</string>
					<key>end</key>
					<string>(?=\)|;)|\n|(&amp;|\|)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function-call.standard.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#redirection</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#argument</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-substitution</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\()</string>
					<key>comment</key>
					<string>Capture "(...)" or "(...)[...]"</string>
					<key>end</key>
					<string>(?&lt;=\))(?!\[)|(?&lt;=\])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\(</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.command-substitution.begin.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The inside of a command substitution is indistinguishable from a global scope</string>
							<key>end</key>
							<string>\)</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.command-substitution.end.fish punctuation.definition.keyword.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.command-substitution.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\[</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.brackets.index-expansion.begin.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>\]</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.brackets.index-expansion.end.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.brackets.index-expansion.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Consumes the remainder of a line after any character which marks the start of a scope with no commands in it. Consumes the newline, thus hiding the entire comment from any scope which seeks newlines</string>
					<key>match</key>
					<string>(?&lt;=^|else|end|\(|;|&amp;|\|)\s*(#).*$\n?</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>comment-inline</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Separate from comment as this is only valid inside of command-call. Does not consume the newline, thus allowing command-call to capture it and end</string>
					<key>match</key>
					<string>(#).*$</string>
					<key>name</key>
					<string>comment.line.insert.fish</string>
				</dict>
			</array>
		</dict>
		<key>control-operator</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This is the only operator which is allowed to exist alone on a line. The other control operators are '&amp;' and '|' however they must be preceded by a command, so command-call matches those</string>
					<key>match</key>
					<string>;</string>
					<key>name</key>
					<string>keyword.operator.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>These four control operators ('&amp;', '|', '&lt;', and '&gt;') must be preceded by a command, so command patterns match them when they are valid. If they are found in the global scope or first inside a command-substitution, that means they are dangling. The control operator '^' is handled in the command-call rule because it is only forbidden from starting a command</string>
					<key>match</key>
					<string>(?&lt;=^|[(;&amp;|])\s*([&amp;|&lt;&gt;]).*$\n?</string>
					<key>name</key>
					<string>invalid.illegal.operator.fish</string>
				</dict>
			</array>
		</dict>
		<key>line-continuation</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This match should be used anywhere line continuation is valid and the newline should be consumed, including cases where it comes alone on a line</string>
					<key>match</key>
					<string>\\\n</string>
					<key>name</key>
					<string>constant.character.escape</string>
				</dict>
			</array>
		</dict>
		<key>loop-control-command</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(break|continue)\b(?!\s+(-|\w))</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>These commands only work as loop control when they are used without arguments</string>
					<key>end</key>
					<string>(?=;)|\n|(&amp;)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#control-operator</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>math</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Only match an operator if the element to the right is whitespace/newline, a variable, or command substitution</string>
					<key>match</key>
					<string>(\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|&lt;[&lt;=]?|&gt;[&gt;=]?|==|!=|^|\|{1,2}|&amp;{1,2}|\?|\:|,|=|[*/%+\-&amp;^|]=|&lt;&lt;=|&gt;&gt;=)(?=(\s|$|\$|\())</string>
					<key>name</key>
					<string>keyword.operator.arithmetic.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>0[xX]\h+</string>
					<key>name</key>
					<string>constant.numeric.hex.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>0\d+</string>
					<key>name</key>
					<string>constant.numeric.octal.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\d{1,2}#[0-9a-zA-Z@_]+</string>
					<key>name</key>
					<string>constant.numeric.other.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\d+</string>
					<key>name</key>
					<string>constant.numeric.integer.fish</string>
				</dict>
			</array>
		</dict>
		<key>pathname</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?&lt;=\s|:|=|^)~</string>
					<key>name</key>
					<string>keyword.operator.tilde.fish</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\*|\?</string>
					<key>name</key>
					<string>keyword.operator.glob.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>([?*+@!])(\()</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.extglob.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.extglob.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\))</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.extglob.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.structure.extglob.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>redirection</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?:([0-9]+)(&lt;|&gt;|&gt;&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;]|(?&lt;=^|\s)\^))(\&amp;)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.dereference.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the integer found before the end match</string>
					<key>end</key>
					<string>(?&lt;=[^&amp;\s]|\n)(?=[\s);&amp;|&lt;&gt;])</string>
					<key>name</key>
					<string>meta.function-call.redirection.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[0-9]+)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:-)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>keyword.operator.redirection.close.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything else is illegal</string>
							<key>match</key>
							<string>(?:\S+.*)$</string>
							<key>name</key>
							<string>invalid.illegal.file-descriptor.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?:([0-9]+)(&lt;|&gt;|&gt;&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;]|(?&lt;=^|\s)\^))(\?)?</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.clobber-test.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the path found before the end match</string>
					<key>end</key>
					<string>(?&lt;=[^&lt;&gt;^?\s]|\n)(?=[\s);&amp;|&lt;&gt;])|(?=\n)</string>
					<key>name</key>
					<string>meta.function-call.redirection.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-inline</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string so path cannot begin with '('</string>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string so path cannot begin with '$'</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Check for characters which are associated with redirection, so path cannot begin with them</string>
							<key>match</key>
							<string>(?:(?:[&amp;?]|[0-9]*[&lt;&gt;^]).*)$</string>
							<key>name</key>
							<string>invalid.illegal.path.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Use the function call match to build a file path, as the syntax is fairly similar (possibly identical, with exceptions caught above)</string>
							<key>match</key>
							<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
							<key>name</key>
							<string>meta.path.fish</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#string-quoted</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string-unquoted</string>
				</dict>
			</array>
		</dict>
		<key>string-quoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \' and \\</string>
							<key>match</key>
							<string>\\[\'\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>\&lt;newline&gt; is accepted</string>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Additional accepted escapes are \", \\, and \$</string>
							<key>match</key>
							<string>\\[\"\\$]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Variable expansion is the only expansion accepted</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\'|\"|\[|\{|\%|^|\s)(?!\'|\"|\]|\}|\s)</string>
					<key>comment</key>
					<string>End string if it precedes the begin of a quoted string, the end of an index/brace expansion (but not a process expansion or stderr redirection as '%' and '^' are valid within names), or anything that would end an argument</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\'|\"|\]|\}|\s|\)|[;&amp;|&lt;&gt;]|$)</string>
					<key>name</key>
					<string>meta.string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string-unquoted-patterns</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns</key>
		<dict>
			<key>comment</key>
			<string>Describes contents of an unquoted string separately for ease of recursion</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#line-continuation</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#command-substitution</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#variable-expansion</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Treat integers as standalone constants if they aren't within strings of alphabetic characters or other special characters permitted within arguments</string>
					<key>match</key>
					<string>(?&lt;![A-Za-z^])[0-9]+(?![A-Za-z^])</string>
					<key>name</key>
					<string>constant.numeric.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>This list follows the order given in official fish documentation, with the addition of additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument</string>
					<key>match</key>
					<string>\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;|;"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]</string>
					<key>name</key>
					<string>constant.character.escape.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.brace-expansion.begin.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\}</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.brace-expansion.end.fish punctuation.definition.keyword.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.brace-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Explicitly treat ',' as a keyword</string>
							<key>match</key>
							<string>\,</string>
							<key>name</key>
							<string>keyword.control.brace-expansion.separator.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?&lt;=\,|\'|\"|\[|\{|^|\s)(?!\,|\'|\"|\]|\}|\s)</string>
							<key>comment</key>
							<string>Begin/end string at same boundaries as before, but ',' can also force a start/stop</string>
							<key>end</key>
							<string>(?&lt;=.|\n)(?=\,|\'|\"|\]|\}|\s|\)|;|&amp;|\||$)</string>
							<key>name</key>
							<string>meta.string.unquoted.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Explicitly allow a ',' to be escaped</string>
									<key>match</key>
									<string>\\\,</string>
									<key>name</key>
									<string>constant.character.escape.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\%</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.process.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Process expansion continues for the entire argument</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=[\s);&amp;|]|$)</string>
					<key>name</key>
					<string>meta.process-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted</string>
					<key>match</key>
					<string>\$(?:(?=[,'"\]}\s);&amp;|])|[^\w\$][^$,'"\]}\s);&amp;|]*)</string>
					<key>name</key>
					<string>invalid.illegal.variable-expansion.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\$)</string>
					<key>comment</key>
					<string>Capture "$foo" or "$foo[]"</string>
					<key>end</key>
					<string>(?&lt;=[\$\w])(?=[^\$\w\[])|(?&lt;=\])</string>
					<key>name</key>
					<string>meta.variable-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\$</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.variable.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Capture "foo"[ or "foo[...]"[</string>
							<key>end</key>
							<string>(?&lt;=[\$\w\]])(?=[^\$\w])|(?&lt;=\])(?=\[)</string>
							<key>name</key>
							<string>variable.other.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#variable-expansion</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\[</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.brackets.index-expansion.begin.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>In other words, the anonymous scope which contains the variable and the index expansion argument list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack</string>
							<key>end</key>
							<string>\]</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.brackets.index-expansion.end.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.brackets.index-expansion.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.fish</string>
	<key>uuid</key>
	<string>f9278d07-f7c1-4a9b-9581-ebcbc050fbfb</string>
</dict>
</plist>
