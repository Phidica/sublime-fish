<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>fileTypes</key>
	<array>
		<string>fish</string>
	</array>
	<key>firstLineMatch</key>
	<string>^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-</string>
	<key>foldingStartMarker</key>
	<string>\b(begin|case|for|if|else|function|switch|while)\b|(\{)$</string>
	<key>foldingStopMarker</key>
	<string>^\s*(\}|(case|else|end)\b)</string>
	<key>keyEquivalent</key>
	<string>^~S</string>
	<key>name</key>
	<string>Shell Script Improved (fish)</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>comment</key>
			<string>Base scope - Pick up '#' and "\\\n" before command-call sees them</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comment-external</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#line-continuation</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#command-chain</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>argument</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=^|\s)(?!\s|#|$)</string>
					<key>comment</key>
					<string>End arg if it precedes whitespace, unescaped control operators, or a newline. Note fish quirk; the stderr redirection operator '^' does not terminate an arg</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\s|\)|[;&amp;|&lt;&gt;]|$)</string>
					<key>name</key>
					<string>meta.argument.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Arguments are made of strings, either quoted or unquoted. The unquoted string rule handles numerics, character escapes, command substitutions, and brace/variable/process expansions</string>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-block</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=begin(?!\s+-)[\s;])</string>
					<key>comment</key>
					<string>The block begin command can be immediately followed by any legal command, however it could also take an option in which case it should be treated as a standard command</string>
					<key>end</key>
					<string>(?=[\n;&amp;|)])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(begin)(?=[\s;])\s*</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?=end[\s;&amp;|)])</string>
							<key>name</key>
							<string>meta.block.begin.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>(end)(?=[\s;&amp;|)])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>meta.block.begin.fish keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?=[\n;&amp;|)])</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#redirection</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(while)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*([;&amp;]))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.while.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(if)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.if.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call</string>
							<key>match</key>
							<string>\b(else(\s*if)?)\b</string>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(for)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*([;&amp;]))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.for-in.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=for)</string>
							<key>end</key>
							<string>(?&lt;=\w)(?=\W)</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Treat the varname like an argument</string>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(in)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?=;)|\n</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>Treat the list as arguments</string>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#loop-control-command</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(switch)\b(?!\s*(-|&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*([;&amp;]))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.switch.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=switch)</string>
							<key>comment</key>
							<string>Value ends at a newline or ';'</string>
							<key>end</key>
							<string>\n|(;)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.block.switch.value.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(case)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>Case block ends before a new case or the end of the switch block</string>
							<key>end</key>
							<string>(?=\b(case|end)\b)</string>
							<key>name</key>
							<string>meta.block.switch.case.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=case)</string>
									<key>comment</key>
									<string>Wildcard ends at a newline or ';'</string>
									<key>end</key>
									<string>\n|(;)</string>
									<key>endCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.fish</string>
										</dict>
									</dict>
									<key>name</key>
									<string>meta.block.switch.case.wildcard.fish</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#argument</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-internal-full</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-internal-end</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-full</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\b(function)\b(?!\s+(&amp;|\|))</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(end)(\s*([;&amp;]))?</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.block.function.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=function)</string>
							<key>comment</key>
							<string>Name and options end at a newline or ';'</string>
							<key>end</key>
							<string>\n|(;)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>(?&lt;=function)\s+</string>
									<key>comment</key>
									<string>Detect the region from just after the `function` command to between the defined function name and the argument or control operators which follow it. Note that we have to account for the fact the defined function name may end in an escaped space</string>
									<key>end</key>
									<string>(?&lt;=\S|\\ )\s*(?=[\S\n;])</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>comment</key>
											<string>The function name may be given using any means that is valid for a command call</string>
											<key>match</key>
											<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
											<key>name</key>
											<string>entity.name.function.fish</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-internal-full</string>
										</dict>
										<dict>
											<key>include</key>
											<string>#comment-internal-end</string>
										</dict>
										<dict>
											<key>comment</key>
											<string>We can't read across lines, so this is needed to catch an escaped newline at the begin of a defined function name</string>
											<key>include</key>
											<string>#line-continuation</string>
										</dict>
									</array>
								</dict>
								<dict>
									<key>comment</key>
									<string>The rest of the patterns are the typical elements of a standard command-call, which is what the `function` command adheres to</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(return)\b(?!\s+(-))</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.control.conditional.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The `return` command can't accept flags</string>
							<key>end</key>
							<string>(?=\)|;)|\n|(&amp;|\|)</string>
							<key>endCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
							</dict>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#argument</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-end</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>$self</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-check-commands</key>
		<dict>
			<key>comment</key>
			<string>The first two should really be handled by command-call-standard, because the strings after the failed command name are highlighted as args by fish. Then, the third could be standalone in command-chain</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\%</string>
					<key>comment</key>
					<string>A command can't begin with a process expansion operator (however the variable expansion operator '$' is allowed)</string>
					<key>end</key>
					<string>(?=[\s;&amp;|)])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\()</string>
					<key>comment</key>
					<string>A command can't begin with an open parenthesis (command substitution). We make sure to match all the way to [\n;&amp;|)] unless a close parenthesis is found, in which case we can stop at [\s;&amp;|)]</string>
					<key>end</key>
					<string>(?=[\s;&amp;|)])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\(</string>
							<key>end</key>
							<string>\)|(?=[\n;&amp;|)])</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>comment</key>
					<string>A command can't be a comment, but this match should only be met when the command is first after a pipe</string>
					<key>end</key>
					<string>(?=[\n)])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
				</dict>
			</array>
		</dict>
		<key>command-call-meta</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(builtin|command|exec)\b(?!\s+[-&amp;|])</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Check if the command is a builtin which takes another command as arguments, ie, a meta command. Because these commands could take options or be backgrounded/piped -- in which case they do not behave as meta commands -- look ahead to ensure that no options or control operators are found. Note also that a meta command forces its argument to behave as a standard command</string>
					<key>end</key>
					<string>(?=[\n;&amp;|)])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-full</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-check-commands</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#command-call-standard</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-call-standard</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>variable.function.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>If this were a *.sublime-syntax then the aformentioned problems could be avoided. We could push the `meta.function-call.standard.fish` and `variable.function.fish` scopes onto the stack simultaneously, then use individual pattern matching on each type of string we find, and finally pop the `variable.function.fish` scope when unescaped whitespace is encountered (hence marking the end of the command name in the command call)</string>
					<key>end</key>
					<string>(?=\s*[\n;&amp;|)])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment-internal-full</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-end</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#redirection</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#argument</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-chain</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>Match an operator which cannot start a command chain (because they are consumed by the command chain when they appear further within it)</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?:[&amp;|])</string>
					<key>name</key>
					<string>invalid.illegal.operator.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Match a command which acts as a unary operator on the command to the right. Neglect the match if it is taking the one valid option argument these commands accept</string>
					<key>match</key>
					<string>(?:and|not|or)(?:(?!\s+(?:-h|--help))|(?=[;&amp;|)]))</string>
					<key>name</key>
					<string>meta.function-call.fish keyword.operator.word.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Match a command which is illegal in the base scope</string>
					<key>match</key>
					<string>(?:case|else|end)(?=[\s;&amp;|)])</string>
					<key>name</key>
					<string>invalid.illegal.function-call.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\S)</string>
					<key>comment</key>
					<string>Anonymous scope - Command chain. Define a command chain as either one command call, or multiple command calls linked by pipes '|'. The chain terminates at the first encounter of any other control operator (newline, ';', '&amp;') or the implied newline of the closing parenthesis of a command substitution</string>
					<key>end</key>
					<string>\n|([;&amp;])|(?=\))</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>meta.function-call.fish keyword.operator.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\)</string>
							<key>comment</key>
							<string>A command can't begin with a close parenthesis. We have to try and match this immediately because the command chain scope will end if the close parenthesis is found by the lookahead</string>
							<key>end</key>
							<string>(?=[\s;&amp;|)])</string>
							<key>name</key>
							<string>meta.function-call.fish invalid.illegal.function-call.fish</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?=\S)</string>
							<key>comment</key>
							<string>Match one command, which may start with a pipe. If it does, perform checks to ensure it is valid. A command call ends at any control operator with the addition of the pipe '|'</string>
							<key>end</key>
							<string>(?=\s*[\n;&amp;|)])</string>
							<key>name</key>
							<string>meta.function-call.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>comment</key>
									<string>If there's no command call after the pipe and the command chain would end quietly, then mark the pipe invalid. We can't lookahead to find a close parenthesis because we want that close parenthesis to be caught and marked invalid. The downside is that this means a pipe at the end of the inside of a command substitution will not be marked invalid, but it turns out the fish parser doesn't do that either!</string>
									<key>match</key>
									<string>\|(?=\s*\n)</string>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
								<dict>
									<key>captures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>keyword.operator.fish</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>invalid.illegal.function-call.fish</string>
										</dict>
									</dict>
									<key>comment</key>
									<string>If there's no command call after the pipe and the command chain would end with an operator, then mark the next control operator (and beyond) as invalid</string>
									<key>match</key>
									<string>(\|)\s*(?=[;&amp;|])(.*)$</string>
								</dict>
								<dict>
									<key>match</key>
									<string>\|</string>
									<key>name</key>
									<string>keyword.operator.fish</string>
								</dict>
								<dict>
									<key>comment</key>
									<string>Match an operator which cannot start a command call but does not stop the next characters from being interpreted as a command</string>
								</dict>
								<dict>
									<key>match</key>
									<string>(?:[&lt;&gt;^])</string>
									<key>name</key>
									<string>invalid.illegal.operator.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#line-continuation</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#comment-internal-full</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-check-commands</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-meta</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-block</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#command-call-standard</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>command-substitution</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?=\()</string>
					<key>comment</key>
					<string>Capture "(...)" or "(...)[...]"</string>
					<key>end</key>
					<string>(?&lt;=\))(?!\[)|(?&lt;=\])</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\(</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.parens.begin.fish</string>
								</dict>
							</dict>
							<key>comment</key>
							<string>The inside of a command substitution is indistinguishable from a global scope</string>
							<key>end</key>
							<string>\)</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.section.parens.end.fish</string>
								</dict>
							</dict>
							<key>name</key>
							<string>meta.parens.command-substitution.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>$self</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#index-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>comment-external</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>A full or inline comment outside of any command call</string>
					<key>end</key>
					<string>\n</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>comment-internal-end</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\#</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>An inline comment at the end of a command call. Does not consume the newline, thus allowing the command call to capture it and end</string>
					<key>end</key>
					<string>(?=\n)</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>comment-internal-full</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>^\s*\#</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>A full line comment inside of a command call that used a line continuation. Consumes the newline, thus hiding the entire comment from the command call scope</string>
					<key>end</key>
					<string>\n</string>
					<key>name</key>
					<string>comment.line.fish</string>
				</dict>
			</array>
		</dict>
		<key>index-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\[</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.brackets.begin.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Note also that command substitution can only have a single index expansion</string>
					<key>end</key>
					<string>\]</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.brackets.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.brackets.index-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\.\.</string>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Manually recreate the</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?&lt;=\.\.|\'|\"|\[|\{|\%|^|\s)(?!\.\.|\'|\"|\]|\}|\s)</string>
							<key>comment</key>
							<string>Begin/end string at same boundaries as before with the addition of breaking at ".." so that the above match can be found multiple times</string>
							<key>end</key>
							<string>(?&lt;=.|\n)(?=\.\.|\'|\"|\]|\}|\s|\)|[;&amp;|&lt;&gt;]|$)</string>
							<key>name</key>
							<string>meta.string.unquoted.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>line-continuation</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>This match should be used anywhere line continuation is valid and the newline should be consumed, including cases where it comes alone on a line</string>
					<key>match</key>
					<string>\\\n</string>
					<key>name</key>
					<string>constant.character.escape</string>
				</dict>
			</array>
		</dict>
		<key>loop-control-command</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\b(break|continue)\b(?!\s+(-|\w))</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.conditional.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>These commands only work as loop control when they are used without arguments</string>
					<key>end</key>
					<string>\n|([;&amp;])</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.fish</string>
						</dict>
					</dict>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-end</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>redirection</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?:([0-9]+)(&lt;|&gt;|&gt;&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;]|(?&lt;=^|\s)\^))(\&amp;)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.dereference.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the integer found before the end match</string>
					<key>end</key>
					<string>(?&lt;=[^&amp;\s]|\n)(?=[\s);&amp;|&lt;&gt;])</string>
					<key>name</key>
					<string>meta.redirection.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-full</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-end</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string which may be an integer</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:[0-9]+)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?:-)(?=[\s);&amp;|&lt;&gt;])</string>
							<key>name</key>
							<string>keyword.operator.redirection.close.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Anything else is illegal</string>
							<key>match</key>
							<string>(?:\S+.*)$</string>
							<key>name</key>
							<string>invalid.illegal.file-descriptor.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?:([0-9]+)(&lt;|&gt;|&gt;&gt;)|(&gt;&gt;|\^\^|[&lt;&gt;]|(?&lt;=^|\s)\^))(\?)?</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.file-descriptor.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.fish</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.redirection.clobber-test.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the path found before the end match</string>
					<key>end</key>
					<string>(?&lt;=[^&lt;&gt;^?\s]|\n)(?=[\s);&amp;|&lt;&gt;])|(?=\n)</string>
					<key>name</key>
					<string>meta.redirection.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-full</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#comment-internal-end</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string so path cannot begin with '('</string>
							<key>include</key>
							<string>#command-substitution</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Evaluates to a string so path cannot begin with '$'</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Check for characters which are associated with redirection, so path cannot begin with them</string>
							<key>match</key>
							<string>(?:(?:[&amp;?]|[0-9]*[&lt;&gt;^]).*)$</string>
							<key>name</key>
							<string>invalid.illegal.path.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Use the function call match to build a file path, as the syntax is fairly similar (possibly identical, with exceptions caught above)</string>
							<key>match</key>
							<string>(?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;;|"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()&lt;&gt;&amp;|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]&lt;&gt;^&amp;;|"'xXuUc])|(?&lt;=\S|\\ )\\\n|(?&lt;=\S|\\ )[~%#])+)+</string>
							<key>name</key>
							<string>meta.path.fish</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#string-quoted</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#string-unquoted</string>
				</dict>
			</array>
		</dict>
		<key>string-quoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\'</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.single.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Only accepted escapes are \' and \\</string>
							<key>match</key>
							<string>\\[\'\\]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>\&lt;newline&gt; is accepted</string>
							<key>include</key>
							<string>#line-continuation</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Additional accepted escapes are \", \\, and \$</string>
							<key>match</key>
							<string>\\[\"\\$]</string>
							<key>name</key>
							<string>constant.character.escape.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Variable expansion is the only expansion accepted</string>
							<key>include</key>
							<string>#variable-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\'|\"|\[|\{|\%|^|\s)(?!\'|\"|\]|\}|\s)</string>
					<key>comment</key>
					<string>End string if it precedes the begin of a quoted string, the end of an index/brace expansion (but not a process expansion or stderr redirection as '%' and '^' are valid within names), or anything that would end an argument</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=\'|\"|\]|\}|\s|\)|[;&amp;|&lt;&gt;]|$)</string>
					<key>name</key>
					<string>meta.string.unquoted.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#string-unquoted-patterns</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>string-unquoted-patterns</key>
		<dict>
			<key>comment</key>
			<string>Describe contents of an unquoted string separately for ease of recursion</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#line-continuation</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#command-substitution</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#variable-expansion</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>Treat integers as standalone constants if they aren't within strings of alphabetic characters or other special characters permitted within arguments</string>
					<key>match</key>
					<string>(?&lt;![A-Za-z^])[0-9]+(?![A-Za-z^])</string>
					<key>name</key>
					<string>constant.numeric.fish</string>
				</dict>
				<dict>
					<key>comment</key>
					<string>This list follows the order given in official fish documentation, with the addition of additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument</string>
					<key>match</key>
					<string>\\[abefnrtv $\\*?#(){}\[\]&lt;&gt;^&amp;|;"']|(?&lt;=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]</string>
					<key>name</key>
					<string>constant.character.escape.fish</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.braces.begin.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\}</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.section.braces.end.fish</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.braces.brace-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Explicitly treat ','</string>
							<key>match</key>
							<string>\,</string>
							<key>name</key>
							<string>punctuation.section.braces.separator.fish</string>
						</dict>
						<dict>
							<key>comment</key>
							<string>Now manually recreate the</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string-quoted</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>(?&lt;=\,|\'|\"|\[|\{|^|\s)(?!\,|\'|\"|\]|\}|\s)</string>
							<key>comment</key>
							<string>Begin/end string at same boundaries as before with the addition of breaking at ',' so that the above match can be found multiple times</string>
							<key>end</key>
							<string>(?&lt;=.|\n)(?=\,|\'|\"|\]|\}|\s|\)|;|&amp;|\||$)</string>
							<key>name</key>
							<string>meta.string.unquoted.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>match</key>
									<string>\\\,</string>
									<key>name</key>
									<string>constant.character.escape.fish</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#string-unquoted-patterns</string>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?&lt;=\[|\{|^|\s)\%</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.process.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Process expansion continues for the entire argument and can include anything but another process expansion</string>
					<key>end</key>
					<string>(?&lt;=.|\n)(?=[\s);&amp;|]|$)</string>
					<key>name</key>
					<string>meta.process-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>comment</key>
							<string>Check if the unquoted string ends after either of these two words. They have special meaning, and though they aren't exactly variables, process expansion is fairly similar to variable expansion</string>
							<key>match</key>
							<string>(self|last)(?=\'|\"|\]|\}|\s|\)|[;&amp;|&lt;&gt;]|$)</string>
							<key>name</key>
							<string>variable.language.fish</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#string</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.tilde.fish</string>
						</dict>
					</dict>
					<key>comment</key>
					<string>Home directory expansion only occurs if the '~' is at the begin of the argument</string>
					<key>match</key>
					<string>(?&lt;=\[|\{|^|\s)\~</string>
					<key>name</key>
					<string>meta.home-directory-expansion.fish</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.double-star.fish</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.single-star.fish</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.question-mark.fish</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\*\*)|(\*)|(\?)</string>
					<key>name</key>
					<string>meta.wildcard-expansion.fish</string>
				</dict>
			</array>
		</dict>
		<key>variable-expansion</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#variable-expansion-illegal</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?=\$)</string>
					<key>comment</key>
					<string>Capture "$foo" or "$foo[]" or "$$foo[][]" etc</string>
					<key>end</key>
					<string>(?&lt;=[\$\w])(?=[^\$\w\[])|(?&lt;=\])(?!\[)</string>
					<key>name</key>
					<string>meta.variable-expansion.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\$</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.variable.fish</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?&lt;=[\$\w])(?=[^\$\w])</string>
							<key>name</key>
							<string>variable.other.fish</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#variable-expansion-illegal</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#variable-expansion-simple</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#index-expansion</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable-expansion-illegal</key>
		<dict>
			<key>comment</key>
			<string>Describe illegal variable expansions separately</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>comment</key>
					<string>A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted</string>
					<key>match</key>
					<string>\$(?:(?=[,'"\]}\s);&amp;|])|[^\w\$][^$,'"\]}\s);&amp;|]*)</string>
					<key>name</key>
					<string>invalid.illegal.variable-expansion.fish</string>
				</dict>
			</array>
		</dict>
		<key>variable-expansion-simple</key>
		<dict>
			<key>comment</key>
			<string>Describe variable expansion that has no index expansion separately</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\$</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.variable.fish</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=[\$\w])(?=[^\$\w])</string>
					<key>name</key>
					<string>variable.other.fish</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#variable-expansion-illegal</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-expansion-simple</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.fish</string>
	<key>uuid</key>
	<string>f9278d07-f7c1-4a9b-9581-ebcbc050fbfb</string>
</dict>
</plist>
