# [PackageDev] target_format: plist, ext: tmLanguage
name: Shell Script Improved (fish)
scopeName: source.fish
fileTypes: [fish]
uuid: f9278d07-f7c1-4a9b-9581-ebcbc050fbfb

patterns:
- comment: These are the patterns which can appear in the base scope
- include: '#block'
- include: '#command-call'
- include: '#comment'
- include: '#control-operator'
- include: '#line-continuation'

# Style guide:
# - keyword.control.conditional is applied to all control keywords that are actually words (if, else, end, function, etc.)
# - support.function is applied to any fish builtins that we have to treat uniquely, however variable.function is used for everything else including other shell builtins
# - constant.character.escape is used for the backslash at the end of a line which causes line continuation because technically that backslash is "escaping" the literal newline which appears in the unquoted string environment which the shell assumes you are in. In this sense, the backslash is indeed an escape character
# - constant.character.escape is used for \x?? and \0?? escape codes rather than constant.numeric.{hex,octal} because even though the user inputs a numeric value in hex or octal, the codes serve the purpose of making characters not numbers
# - Individual arguments in function calls do not get the variable.parameter label because that swiftly becomes the overwhelming majority of all words in a program

#! \todo Bug: Keywords that only work in loops or functions (eg, "continue", "return", etc) will be treated like standard commands if they are located within if-statements within those outer valid blocks. Without a scope stack, we'll have to treat them as always being keywords rather than trying to parse them for the user
#! \todo Known bug: if a command-call line ends in "end" then a comment following it on the line will not be of the insert type, causing the next line of text to be considered arguments. fixing may require a rethink of the two comment contexts and finding a way to merge them (the key difference is whether the newline is consumed and command-call either terminates or perpetuates based on that)
#!  BETTER FIX?: Newlines are consumed at the end of command calls. create a pattern in the block group which begins just after the word 'end' when it has no newline after it, and ends at the next newline. everything in between can be any group that's valid (pipes, backgrounding, redirection). this would perhaps get us out of the special piped function group described below
#! \todo add comment-inline to the recursive command-call. no point adding comment because recursive will /always/ have ended by the time a full line comment shows up
#! \todo add special behaviour to parameter expansion arguments like ~
#! \todo redirection. need to make [<^>] into control operators nearly everywhere (thus excluding them from the argument selection) (but don't make them function call terminators for instance) and add a redirection group that's included in function calls at the same level as argument
#! \todo a specific version of command-call which is just `test` and the possible expressions all highlighted special, as well as the `[ ]` form
#! \todo piping with | is more complicated than it seems, as fish expects a command to appear after the pipe. make a pattern match in command-call that is only valid inside of a command call that used the pipe, and matches from after a pipe until the end of the line, looking for command-call within it
#!  Hm, because it is possible to pipe the output of an entire block by putting the pipe after `end`, a better approach may be to make a command that STARTS with a pipe, and is normal after that. then it can check inside itself to see if it is ONLY a pipe with no command following it, and mark that as invalid syntax. that would supersede the need for pipe to be matched invalid from in control-operator

repository:
  argument:
    patterns:
    - name: meta.function-call.argument.fish
      comment: An argument is one of the fundamental units, however we define it by the very essence of not being any of the other fundamental units '#' and the control operators (';', '&', and '|'). All those have special treatment when they appear in command-calls, so we attend to them uniquely
      begin: (?<=^|\s)(?!\s|#|$)
      comment: Begin arg at a boundary. Before the boundary must be the begin of line (for when a command-call spans multiple lines) or whitespace. After the boundary may be anything but whitespace, a comment character, or a newline (to prevent blank lines being called args)
      end: (?<=.|\n)(?=\s|\)|[;&|<>]|$)
      comment: End arg if it precedes whitespace, unescaped control operators, or a newline. Note fish quirk; the stderr redirection operator '^' does not terminate an arg
      patterns:
      - include: '#string'
        comment: Arguments are made of strings, either quoted or unquoted. The unquoted string rule handles numerics, character escapes, command substitutions, and brace/variable/process expansions

  block:
    patterns:
    - name: meta.block.begin.fish
      begin: \b(begin)\b(?!\s*(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.operator.fish}
      patterns:
      - include: '$self'

    - name: meta.block.while.fish
      begin: \b(while)\b(?!\s*(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.operator.fish}
      patterns:
      - include: '#loop-control-command'
      - include: '$self'

    - name: meta.block.if.fish
      begin: \b(if)\b(?!\s*(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.operator.fish}
      patterns:
      - name: keyword.control.conditional.fish
        match: \b(else(\s*if)?)\b
        comment: Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call
      - include: '$self'

    - name: meta.block.for-in.fish
      begin: \b(for)\b(?!\s*(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.operator.fish}
      patterns:
      - begin: (?<=for)
        end: (?<=\w)(?=\W)
        patterns:
        - include: '#argument'
          comment: Treat the varname like an argument
        - include: '#comment'
      - begin: \b(in)\b
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (?=;)|\n
        patterns:
        - include: '#argument'
          comment: Treat the list as arguments
        - include: '#comment'
        - include: '#comment-inline'
      - include: '#loop-control-command'
      - include: '$self'

    - name: meta.block.switch.fish
      begin: \b(switch)\b(?!\s*(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.operator.fish}
      patterns:
      - name: meta.block.switch.value.fish
        begin: (?<=switch)
        end: (?=;)|\n
        comment: Value ends before ';' or at a newline
        patterns:
        - include: '#argument'
        - include: '#comment'
        - include: '#comment-inline'
      - name: meta.block.switch.case.fish
        begin: \b(case)\b
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (?=\b(case|end)\b)
        comment: Case block ends before a new case or the end of the switch block
        patterns:
        - name: meta.block.switch.case.wildcard.fish
          begin: (?<=case)
          end: (?=;)|\n
          comment: Wildcard ends before ';' or at a newline
          patterns:
          - include: '#argument'
          - include: '#comment'
          - include: '#comment-inline'
        - include: '$self'
      - include: '#comment'
      - include: '#control-operator'

    - name: meta.block.function.fish
      begin: \b(function)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.operator.fish}
      patterns:
      - begin: (?<=function)
        end: (?=;)|\n
        comment: Name and options end before ';' or at a newline
        patterns:
        - begin: (?<=function)\s+
          end: (?<=\S|\\ )\s*(?=\S|;|\n)
          comment: Detect the region from just after the `function` command to between the defined function name the argument or control operators which follow it. Note that we have to account for the fact the defined function name may end in an escaped space
          patterns:
          - match: (?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]<>^&;|"']|(?<=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()<>&|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]<>^&;|"'xXuUc])|(?<=\S|\\ )\\\n|(?<=\S|\\ )[~%#])+)+
            name: entity.name.function.fish
            comment: The function name may be given using any means that is valid for a command call
          - include: '#comment'
          - include: '#comment-inline'
          - include: '#line-continuation'
            comment: We can't read across lines, so this is needed to catch an escaped newline at the start of a defined function name
        - comment: The rest of the patterns are the typical elements of a standard command-call, which is what the `function` command adheres to
        - include: '#argument'
        - include: '#comment'
        - include: '#comment-inline'
      - begin: \b(return)\b(?!\s+(-))
        beginCaptures:
          '1': {name: keyword.control.conditional.fish}
        end: (?=\)|;)|\n|(&|\|)
        endCaptures:
          '1': {name: keyword.operator.fish}
        comment: The `return` command can't accept flags
        patterns:
        - include: '#argument'
        - include: '#comment'
        - include: '#comment-inline'
      - include: '$self'

  command-call:
    patterns:
    - name: meta.function-call.recursive.fish
      comment: Check if the command name is a builtin corresponding to a command that takes another command as arguments, ie, to recursively contain another command-call. Because some builtins can instead take switches, or be backgrounded/piped (in which case they should be considered user commands), look ahead to ensure that no switches or bg/pipe control operators are found
      begin: \b((builtin|command|exec)|(and|not|or))\b(?!\s+(-|&|\|))
      comment: (?!\s+(-|&|\|)) is equivalent to (?= \s+ then \S except '-' '&' and '|')
      beginCaptures:
        '2': {name: support.function.fish}
        '3': {name: keyword.operator.word.fish}
      end: (?=\)|;)|(?<=\n|&|\|)
      comment: Recursive command-call ends before ')' or ';', and just after a newline, '&', or '|'. Standard command-call will have consumed the '&' or '|'. Unfortunately, we cannot help but end after any newline we encounter, as the standard command-call only ends when it consumes a newline (allowing us to insert comments by having the comment consume its newline and prevent command-call matching it) and we cannot distinguish between a newline that was consumed by a command and a newline that was consumed by a comment. Put simply, this means that when a recursive command-call reaches a newline before its first standard command-call, the scope ends and the standard command-call on the next line loses the recursive command-call scope
      patterns:
      - include: '#line-continuation'
      - include: '#block'
      - include: '#command-call'

    - name: invalid.illegal.function.fish
      comment: Search for illegal commands; these aren't valid outside of their use in blocks
      match: \b(?:case|else|end)\b.*$\n?

    - name: invalid.illegal.operator.fish
      comment: Search for illegal operators; these aren't allowed to start a command, but can appear unescaped later within it
      match: (?<=^|[(;&|\s])[%^].*$\n?

    - name: meta.function-call.standard.fish
      comment: If the above match for recursive commands failed, try and match legal standard commands
      begin: (?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]<>^&;|"']|(?<=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()<>&|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]<>^&;|"'xXuUc])|(?<=\S|\\ )\\\n|(?<=\S|\\ )[~%#])+)+
      beginCaptures:
        '0': {name: variable.function.fish}
      comment: In fish, commands can be called using any arbitrary combination of quoted and unquoted strings (with a modified set of characters that need to be escaped, pointless escapes expanded into two literal characters, the literal newline allowed if escaped provided it's not the sole character, the comment character allowed if it's not at the front, etc), so we must manually repeat all the definitions of single-quoted, double-quoted, and unquoted strings. Unfortunately, only a single instance of a non-zero `beginCapture` match can be assigned a scope, so it isn't possible to account for the fact that an arbitrary number of strings can be in the command name and give them all the appropriate string scopes. Furthermore, a `begin` match cannot check across multiple lines, so even though line breaks are permitted inside of double-quoted strings we cannot see to the next line and determine that such a command name would be valid
      comment: If this were a *.sublime-syntax then the aformentioned problems could be avoided. We could push the `meta.function-call.standard.fish` and `variable.function.fish` scopes onto the stack simultaneously, then use individual pattern matching on each type of string we find, and finally pop the `variable.function.fish` scope when unescaped whitespace is encountered (hence marking the end of the command name in the command call)
      end: (?=\)|;)|\n|(&|\|)
      endCaptures:
        '1': {name: keyword.operator.fish}
      comment: Command call ends before ')' or ';', and at a newline, '&', or '|'. Those last two control operators must be part of a command, so consume them here
      patterns:
      - include: '#redirection'
      - include: '#argument'
      - include: '#comment'
      - include: '#comment-inline'

  command-substitution:
    patterns:
    - begin: (?=\()
      end: (?<=\))(?!\[)|(?<=\])
      comment: Capture "(...)" or "(...)[...]"
      patterns:
      - name: meta.command-substitution.fish
        comment: The inside of a command substitution is indistinguishable from a global scope
        begin: \(
        beginCaptures:
          '0': {name: keyword.control.command-substitution.begin.fish punctuation.definition.keyword.fish}
        end: \)
        endCaptures:
          '0': {name: keyword.control.command-substitution.end.fish punctuation.definition.keyword.fish}
        patterns:
        - include: '$self'

      - name: meta.brackets.index-expansion.fish
        begin: \[
        beginCaptures:
          '0': {name: punctuation.section.brackets.index-expansion.begin.fish}
        end: \]
        endCaptures:
          '0': {name: punctuation.section.brackets.index-expansion.end.fish}
        patterns:
        - include: '#string'

  comment:
    patterns:
    - name: comment.line.fish
      comment: Consumes the remainder of a line after any character which marks the start of a scope with no commands in it. Consumes the newline, thus hiding the entire comment from any scope which seeks newlines
      match: (?<=^|else|end|\(|;|&|\|)\s*(#).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.fish}

  comment-inline:
    patterns:
    - name: comment.line.insert.fish
      comment: Separate from comment as this is only valid inside of command-call. Does not consume the newline, thus allowing command-call to capture it and end
      match: (#).*$
      captures:
        '1': {name: punctuation.definition.comment.fish}

  control-operator:
    patterns:
    - name: keyword.operator.fish
      match: ;
      comment: This is the only operator which is allowed to exist alone on a line. The other control operators are '&' and '|' however they must be preceded by a command, so command-call matches those
    - name: invalid.illegal.operator.fish
      match: (?<=^|[(;&|])\s*([&|<>]).*$\n?
      comment: These four control operators ('&', '|', '<', and '>') must be preceded by a command, so command patterns match them when they are valid. If they are found in the global scope or first inside a command-substitution, that means they are dangling. The control operator '^' is handled in the command-call rule because it is only forbidden from starting a command

  line-continuation:
    patterns:
    - name: constant.character.escape
      match: \\\n
      comment: This match should be used anywhere line continuation is valid and the newline should be consumed, including cases where it comes alone on a line

  loop-control-command:
    patterns:
    - begin: \b(break|continue)\b(?!\s+(-|\w))
      comment: These commands only work as loop control when they are used without arguments
      beginCaptures:
        '1': {name: keyword.control.conditional.fish}
      end: (?=;)|\n|(&)
      endCaptures:
        '1': {name: keyword.operator.fish}
      patterns:
      - include: '#comment-inline'
      - include: '#control-operator'
      - include: '#line-continuation'

  redirection:
    patterns:
    - name: meta.function-call.redirection.fish
      comment: This redirection pattern is from file descriptor (either explicit or implied) to file path
      begin: (?:([0-9]+)(<|>|>>)|(>>|\^\^|[<>]|(?<=^|\s)\^))(\?)?
      beginCaptures:
        '1': {name: constant.numeric.file-descriptor.fish}
        '2': {name: keyword.operator.redirection.fish}
        '3': {name: keyword.operator.redirection.fish}
        '4': {name: keyword.operator.redirection.clobber-test.fish}
      comment: Begin at any of the redirections valid for a file path (main difference is that the '?' can be used to prevent clobber). Note that the stderr redirection operator '^' must be preceded by whitespace and cannot be preceded by a file descriptor
      end: (?<=[^<>^?\s]|\n)(?=[\s);&|<>])
      comment: End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the path found before the end match
      patterns:
      - include: '#line-continuation'
      - include: '#comment'
      - include: '#comment-inline'
      - include: '#command-substitution'
        comment: Evaluates to a string so path cannot begin with '('
      - include: '#variable-expansion'
        comment: Evaluates to a string so path cannot begin with '$'
      - name: invalid.illegal.path.fish
        comment: Check for characters which are associated with redirection, so path cannot begin with them
        match: (\?|[0-9]*[<>^]).*$
      - name: meta.path.fish
        comment: Use the function call match to build a file path, as the syntax is fairly similar (possibly identical, with exceptions caught above)
        match: (?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]<>^&;|"']|(?<=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()<>&|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]<>^&;|"'xXuUc])|(?<=\S|\\ )\\\n|(?<=\S|\\ )[~%#])+)+

    # todo: add the redirection pattern from file descriptor (either explicit or implied) to file descriptor (uses only < or > followed by an ampersand, space, then an int or a hyphen)

    # todo: remove the todos for redirection! (top of file, readme) but remember, there's still the special case redirection into a pipe which you should match wherever the pipe patterns go

  string:
    patterns:
    - include: '#string-quoted'
    - include: '#string-unquoted'

  string-quoted:
    patterns:
    - name: string.quoted.single.fish
      begin: \'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \'
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\'\\]
        comment: Only accepted escapes are \' and \\

    - name: string.quoted.double.fish
      begin: \"
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \"
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - include: '#line-continuation'
        comment: \<newline> is accepted
      - name: constant.character.escape.fish
        match: \\[\"\\$]
        comment: Additional accepted escapes are \", \\, and \$
      - include: '#variable-expansion'
        comment: Variable expansion is the only expansion accepted

  string-unquoted:
    patterns:
    - name: string.unquoted.fish
      begin: (?<=\'|\"|\[|\{|\%|^|\s)(?!\'|\"|\]|\}|\s)
      comment: Begin string at a boundary. Before the boundary must be the end of a quoted string, the begin of an index/brace/process expansion, or anything that would initiate a function-call argument. After the boundary may be anything that isn't the begin of a quoted string, the end of an item-access argument list, the end of a brace expansion, or whitespace
      end: (?<=.|\n)(?=\'|\"|\]|\}|\s|\)|[;&|<>]|$)
      comment: End string if it precedes the begin of a quoted string, the end of an index/brace expansion (but not a process expansion or stderr redirection as '%' and '^' are valid within names), or anything that would end an argument
      patterns:
      - include: '#string-unquoted-patterns'

  string-unquoted-patterns:
    comment: Describes contents of an unquoted string separately for ease of recursion
    patterns:
    - include: '#line-continuation'

    - include: '#command-substitution'

    - include: '#variable-expansion'

    - name: constant.numeric.fish
      match: (?<![A-Za-z^])[0-9]+(?![A-Za-z^])
      comment: Treat integers as standalone constants if they aren't within strings of alphabetic characters or other special characters permitted within arguments

    - name: constant.character.escape.fish
      match: \\[abefnrtv $\\*?#(){}\[\]<>^&|;"']|(?<=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]
      comment: This list follows the order given in official fish documentation, with the addition of additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument

    - name: meta.brace-expansion.fish
      begin: \{
      beginCaptures:
        '0': {name: keyword.control.brace-expansion.begin.fish punctuation.definition.keyword.fish}
      end: \}
      endCaptures:
        '0': {name: keyword.control.brace-expansion.end.fish punctuation.definition.keyword.fish}
      patterns:
      - name: keyword.control.brace-expansion.separator.fish
        match: \,
        comment: Explicitly treat ',' as a keyword
      - include: '#string-quoted'
      - name: string.unquoted.fish
        comment: We could name this scope differently if we wished, as we know that it must be occurring inside of a brace expansion
        begin: (?<=\,|\'|\"|\[|\{|^|\s)(?!\,|\'|\"|\]|\}|\s)
        end: (?<=.|\n)(?=\,|\'|\"|\]|\}|\s|\)|;|&|\||$)
        comment: Begin/end string at same boundaries as before, but ',' can also force a start/stop
        patterns:
        - name: constant.character.escape.fish
          match: \\\,
          comment: Explicitly allow a ',' to be escaped
        - include: '#string-unquoted-patterns'

    - name: meta.process-expansion.fish
      begin: \%
      beginCaptures:
        '0': {name: punctuation.definition.process.fish}
      end: (?<=.|\n)(?=[\s);&|]|$)
      comment: Process expansion continues for the entire argument
      patterns:
      - include: '#string'

  variable-expansion:
    patterns:
    - name: invalid.illegal.variable-expansion.fish
      match: \$(?:(?=[,'"\]}\s);&|])|[^\w\$][^$,'"\]}\s);&|]*)
      comment: A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for string.unquoted

    - name: meta.variable-expansion.fish
      begin: (?=\$)
      end: (?<=[\$\w])(?=[^\$\w\[])|(?<=\])
      comment: Capture "$foo" or "$foo[]"
      patterns:
      - name: variable.other.fish
        begin: \$
        beginCaptures:
          '0': {name: punctuation.definition.variable.fish}
        end: (?<=[\$\w\]])(?=[^\$\w])|(?<=\])(?=\[)
        comment: Capture "foo"[ or "foo[...]"[
        patterns:
        - include: '#variable-expansion'
      - name: meta.brackets.index-expansion.fish
        comment: The number of index expansion argument lists `[...]` should always be less than or equal to the number of variable expansion operators `$`. Unfortunately, we can do nothing to moderate that with this syntax schema; with a *.sublime-syntax and a scope stack it could be done. As it stands, "$$foo[...]" is the deepest that we can accurately highlight
        comment: In other words, the anonymous scope which contains the variable and the index expansion argument list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack
        begin: \[
        beginCaptures:
          '0': {name: punctuation.section.brackets.index-expansion.begin.fish}
        end: \]
        endCaptures:
          '0': {name: punctuation.section.brackets.index-expansion.end.fish}
        patterns:
        - include: '#string'

  # Inherited constructs; to be rewritten

  math:
    patterns:
    - name: keyword.operator.arithmetic.fish
      match: (\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|<[<=]?|>[>=]?|==|!=|^|\|{1,2}|&{1,2}|\?|\:|,|=|[*/%+\-&^|]=|<<=|>>=)(?=(\s|$|\$|\())
      comment: Only match an operator if the element to the right is whitespace/newline, a variable, or command substitution
    - name: constant.numeric.hex.fish
      match: 0[xX]\h+
    - name: constant.numeric.octal.fish
      match: 0\d+
    - name: constant.numeric.other.fish
      match: \d{1,2}#[0-9a-zA-Z@_]+
    - name: constant.numeric.integer.fish
      match: \d+

  pathname:
    patterns:
    - name: keyword.operator.tilde.fish
      match: (?<=\s|:|=|^)~
    - name: keyword.operator.glob.fish
      match: \*|\?
    - name: meta.structure.extglob.fish
      begin: ([?*+@!])(\()
      beginCaptures:
        '1': {name: keyword.operator.extglob.fish}
        '2': {name: punctuation.definition.extglob.fish}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.extglob.fish}
      patterns:
      - include: $self

firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|case|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(case|else|end)\b)
keyEquivalent: ^~S
