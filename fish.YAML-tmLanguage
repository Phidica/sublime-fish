# [PackageDev] target_format: plist, ext: tmLanguage
name: Shell Script (fish)
scopeName: source.fish
fileTypes: [fish]
uuid: a6b750ed-a12a-43c1-84e7-689ac7e2fbc9

patterns:
- include: '#command-call'
- include: '#comment'
  # probably this global scope will only allow comment, command-call, and block, once I write a block structure (begin, if, function, ...)

# - include: '#function-definition'
# - include: '#keyword'
# - include: '#list'
# - include: '#logical-expression'
# - include: '#loop'
# - include: '#math'
# - include: '#pathname'
# - include: '#pipeline'
# - include: '#redirection'
# - include: '#string'
# - include: '#support'
# - include: '#variable'

repository:
  argument:
    patterns:
    - name: function.call.argument.fish #! \todo Find the right name, it's not this
      comment: An argument is one of the fundamental units, however we define it by the very essence of not being any of the other fundamental units #, \, or control characters. All those have special treatment when they appear in command-calls, so we attend to them uniquely
      begin: (?<=^|\s)(?!\s|#|$|\\$)
      comment: Begin arg at the boundary between whitespace (or beginline for when command-call escapes its endline) and anything but whitespace, a comment character (because a lone # can't be an arg), an endline (to prevent blank lines being called args), or an escaped endline (because command-call can spot a lone \ and match it)
      comment: Known bug - ` echo \ #` is supposed to print " #" because the whitespace is forced to become a character and then the # isn't considered lone because forced whitespace precedes it. So "\ #" should be one arg
      end: (?<=\S)(?=\s|\)|;|&|\||$)
      comment: End arg if it precedes unescaped control characters. This could prove troublesome for arguments like --foo=";" unless argument is extended to permit strings after = signs. fish assumes a command call ends at an arg like --foo=; so we should too
      patterns:
      # - include: '#constant' #! \todo This will be things like lone numbers and escape characters, even though fish doesn't treat numbers any differently
      - include: '#string'
      - include: '#variable'
      - include: '#command-substitution'
      # - match: '[\w-]+' # This probably isn't needed, get rid of it later

  command-call:
    patterns:
    - name: meta.command-call.fish
      begin: \b([\w][\w-]*)\b
      beginCaptures:
        '1': {name: support.function.user.fish}
      end: (?=\))|(;|&|\|)|(?<!\\)(?=\n)
      endCaptures:
        '1': {name: keyword.control.fish}
      comment: command call ends at ), ;, &, |, or an unescaped endline
      patterns:
      - include: '#argument'
      - include: '#comment'
      - include: '#comment-inline'
      - name: constant.character.escape
        match: \\(?=\n)

  command-substitution:
    patterns:
    - name: meta.command-substitution.fish
      comment: Multiple command-calls may appear in a command-substitution, separated by unescaped endlines
      begin: \(
      beginCaptures:
        '0': {name: constant.character.command-substitution.fish}
      end: \)
      endCaptures:
        '0': {name: constant.character.command-substitution.fish}
      patterns:
      - include: '#command-call'
      - include: '#comment'

  comment:
    patterns:
    - name: comment.line.number-sign.fish
      comment: Consumes the entire line, including the endline, thus hiding the entire comment from command-call
      match: ^\s*(#).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.fish}

  comment-inline:
    patterns:
    - name: comment.line.number-sign.fish
      comment: Does not consume the endline, thus allowing the command-call to capture it and end. Note that a comment won't start if escaped whitespace precedes the # character
      comment: Known bug - If comment line ends with \ then since it didn't consume the endline, a command-call will NOT end because command-call doesn't end if an endline it encountered had a \ preceding it. Solution may be to have comment-inline match the endline character if it is preceded by a \, but not sure how to implement
      match: (?<=^|[^\\]\s)(#).*(?=$\n)
      captures:
        '1': {name: punctuation.definition.comment.fish}

  function-definition:
    patterns:
    - name: meta.function.fish
      begin: \b(function)\s+([^\s\\]+)(?:\s*(\(\)))?
      beginCaptures:
        '1': {name: storage.type.function.fish}
        '2': {name: entity.name.function.fish}
        '3': {name: punctuation.definition.arguments.fish}
      end: ;|&|$
      endCaptures:
        '1': {name: punctuation.definition.function.fish}
      patterns:
      - include: $self

  keyword:
    patterns:
    - name: keyword.control.fish
      match: \b(?:and|begin|break|case|continue|else|end|for|if|in|return|switch|while)\b
    - name: storage.modifier.fish
      match: (?<![-/])\b(?:set)\b

  list:
    patterns:
    - name: keyword.operator.list.fish
      match: ;|&&|&|\|\|

  logical-expression:
    patterns:
    - comment: do we want a special rule for ( expr )?
      name: keyword.operator.logical.fish
      match: =[=~]?|!=?|<|>|&&|\|\|
    # - name: keyword.operator.logical.fish
    #   match: (?<!\S)-(nt|ot|ef|eq|ne|l[te]|g[te]|[a-hknoprstuwxzOGLSN])

  loop:
    patterns:
    - name: meta.scope.for-loop.fish
      begin: \b(for)\s+(?=\({2})
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.for-in-loop.fish
      begin: \b(for)\s+((?:[^\s\\]|\\.)+)\b
      beginCaptures:
        '1': {name: keyword.control.fish}
        '2': {name: variable.other.loop.fish}
      end: \b(end)\b
      endCaptures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.while-loop.fish
      begin: \b(while)\b
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.case-block.fish
      match: \b(case)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.if-block.fish
      begin: \b(if)\b
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self

  math:
    patterns:
    - name: keyword.operator.arithmetic.fish
      match: (\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|<[<=]?|>[>=]?|==|!=|^|\|{1,2}|&{1,2}|\?|\:|,|=|[*/%+\-&^|]=|<<=|>>=)(?=(\s|$|\$|\())
      comment: Only match an operator if the element to the right is whitespace/endline, a variable, or command substitution
    - name: constant.numeric.hex.fish
      match: 0[xX]\h+
    - name: constant.numeric.octal.fish
      match: 0\d+
    - name: constant.numeric.other.fish
      match: \d{1,2}#[0-9a-zA-Z@_]+
    - name: constant.numeric.integer.fish
      match: \d+
    - include: '#variable'

  pathname:
    patterns:
    - name: keyword.operator.tilde.fish
      match: (?<=\s|:|=|^)~
    - name: keyword.operator.glob.fish
      match: \*|\?
    - name: meta.structure.extglob.fish
      begin: ([?*+@!])(\()
      beginCaptures:
        '1': {name: keyword.operator.extglob.fish}
        '2': {name: punctuation.definition.extglob.fish}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.extglob.fish}
      patterns:
      - include: $self

  pipeline:
    patterns:
    - name: keyword.operator.pipe.fish
      match: '[|!]'

  redirection:
    patterns:
    - name: string.interpolated.process-substitution.fish
      begin: '[><]\('
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - include: $self
    - comment: 'valid: &>word >&word >word [n]>&[n] [n]<word [n]>word [n]>>word [n]<&word
        (last one is duplicate)'
      name: keyword.operator.redirect.fish
      match: '&>|\d*>&\d*|\d*(>>|>|<)|\d*<&|\d*<>'

  # fish strings accept very few escape codes, quite unlike Bash, make only a few simple distinctions between the single- and double-quoted variants
  string:
    patterns:
    - name: string.quoted.single.fish
      begin: \'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \'
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\'\\]
        comment: Only accepted escapes are \' and \\
    - name: string.quoted.double.fish
      begin: \"
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \"
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\"$\n\\]
        comment: Only accepted escapes are \", \$, \<newline>, and \\
      - include: '#variable'

  support:
    patterns:
    - comment: Matches literal . (alias for source, may be deprecated in future)
      name: support.function.builtin.fish
      match: (?<=^|\s)(?::|\.)(?=\s|;|&|$)
    - name: support.function.builtin.fish
      match: (?<![-/])\b(?:abbr|alias|bg|bind|block|breakpoint|builtin|cd|command|commandline|complete|contains|count|dirh|dirs|echo|emit|eval|exec|exit|false|fg|fish|fish_config|fish_indent|fish_prompt|fish_realpath|fish_right_prompt|fish_update_completions|fish_vi_mode|funced|funcsave|function|functions|help|history|isatty|jobs|math|nextd|not|open|popd|prevd|printf|prompt_pwd|psub|pushd|pwd|random|read|return|set|set_color|source|status|string|suspend|test|trap|true|type|ulimit|umask|vared)\b

  variable:
    patterns:
    - name: variable.other.fish
      comment: fish variables can only be word characters and no special treatment is necessary
      match: (\$)\w+(?=\W)
      captures:
        '1': {name: punctuation.definition.variable.fish }

firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(else|end)\b)
keyEquivalent: ^~S
