# [PackageDev] target_format: plist, ext: tmLanguage
name: friendly interactive shell (fish)
scopeName: source.shell.fish
fileTypes: [fish]
uuid: f9278d07-f7c1-4a9b-9581-ebcbc050fbfb

# Style guide:
# - The fish docs for `complete` define the fundamental units passed to commands as "parameters", where those which start with a hyphen are "options" and those which don't are "arguments". For optimum usefulness to the user, only options receive the variable.parameter scope
# - `keyword.control.conditional` is applied to all control keywords that are actually words (if, else, end, function, etc.)
# - `support.function` is applied to any fish builtins that we have to treat uniquely, however `variable.function` is used for everything else including other shell builtins
# - `constant.character.escape` is used for the backslash at the end of a line which causes line continuation because technically that backslash is "escaping" the literal newline which appears in the unquoted string environment which the shell assumes you are in. In this sense, the backslash is indeed an escape character
# - `constant.character.escape` is used for \x?? and \0?? escape codes rather than `constant.numeric.{hex,octal}` because even though the user inputs a numeric value in hex or octal, the codes serve the purpose of making characters not numbers
# - By analogy to the recommendation that `meta.function.php meta.function.parameters.php` should never occur, we use a single `meta.function-call` scope and name the parameter scope `meta.parameter` not `meta.function-call.parameter`. Furthermore, a single `meta.function-call` scope continues from the first command name until the consumption of a ';', '&', or '\n'. The same scope continues through '|' because we have no other way to ensure that a command follows a '|'
# - Every character outside of comments should be scoped as `meta.string.unquoted`, `string.quoted.single`, or `string.quoted.double`. Furthermore, there is no concept of an unquoted string inside a quoted string or vice-versa
# - We recognise the existence of operator characters (which directly instruct shell behaviour) and pseudo-operator characters (which guide shell behaviour). The convention for the order of operators in expressions is:
#   - (Pseudo-operator) Whitespace: '\s' (includes newline)
#   - Control operators: newline '\n', ';', '&', and the implied newline of encountering ')'
#   - (Pseudo-operator) Command substitution: '(' and ')'
#   - Pipe operators (including redirection-into-pipe): '|', '<|', '>>|', '3>|', etc
#   - Redirect operators: '<', '>', '^'
#   - (Pseudo-operator) Option: '-'
# - fish functions (defined with a call to the `function` builtin) cannot begin with a hyphen, however commands (any executable files on the user's $PATH) can begin with a hyphen and are executed without trouble. To this end, we never forbid a command call from beginning with a hyphen
# - When I talk about "anonymous" scopes in this document I'm referring to the absence of a "name:" element on a begin/end pattern that encompasses a pretty particular concept that one might expect to have a name on it. Sometimes the lack of a name is better for recursion, other times it's so that even better, more specific names can be exclusively assigned to the contents

patterns:
  # Base scope - Pick up '#' and "\\\n" before command-call sees them
  # This will include comments that are alone on a line, or sit after a command that is terminated by a visible control operator
  - include: '#comment-external'
  - include: '#line-continuation'

  - comment: The first command of a pipeline can't begin with a close parenthesis or be "end". We match this so exclusively early because the base pipeline scope will end immediately if either is seen by its lookahead
    comment: In an ideal world, #command-call-standard would be performing this match because fish considers the strings which follow as parameters, not as new functions. But we can't do that in a tmLanguage
    name: invalid.illegal.function-call.fish
    begin: \)|end
    end: (?=[\s;&)|<>])

  - comment: The first character of a pipeline can't be an '&', and the base pipeline scope won't be able to mark it as invalid so we have to do so here
    name: invalid.illegal.function-call.fish
    match: \&

  - comment: Anonymous scope - Base scope pipeline, goes up until a definitive end (typical control operators) or the sequences that could be an end if we're actually inside a $self scope right now (')' and "end")
    begin: (?=\S)
    end: (\n)|([;&])|(?=\)|end)
    endCaptures:
      '1': {name: meta.function-call.operator.fish}
      '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
    patterns:
      - include: '#pipeline'

repository:
  separator-whitespace:
    patterns:
      - comment: Fundamental structure used to separate elements of a command call; it's any whitespace that isn't a newline, predominantly meaning spaces or tabs
        name: meta.function-call.fish
        match: (?:[^\n\S]+)

  parameter:
    patterns:
      - comment: See the argument rule for more general information on parameters
        begin: (?![\s;&)|<>^])
        end: (?=[\s;&)|<>])
        patterns:
          - comment: End of options (parameter of just two hyphens)
            name: meta.function-call.fish meta.parameter.option.end.fish variable.parameter.fish punctuation.definition.option.end.fish meta.string.unquoted.fish
            match: (?:--)(?=[\s;&)|<>])

          - comment: Long option (parameter starting with two hyphens)
            name: meta.function-call.fish meta.parameter.option.long.fish
            begin: (?=--)
            end: (?=[\s;&)|<>])
            patterns:
              - name: variable.parameter.fish
                begin: (?:--)
                beginCaptures:
                  '0': {name: punctuation.definition.option.long.begin.fish meta.string.unquoted.fish}
                end: (?=[\s;&)|<>]|=)
                patterns:
                  # We mimic the parameter-patterns rule but use a tweaked unquoted string pattern which excludes '='
                  - include: '#command-substitution'

                  - name: meta.string.unquoted.fish
                    begin: (?=\$)
                    end: (?!\$)
                    patterns:
                      - include: '#variable-expansion'

                  - include: '#string-quoted'

                  - name: meta.string.unquoted.fish
                    begin: (?!['"])
                    end: (?=[\s;&()|<>'"$]|\=)
                    patterns:
                      - include: '#string-unquoted-patterns'

              - comment: Consume the '=' and then use standard parameter patterns as well as numerics
                begin: (?:=)
                beginCaptures:
                  '0': {name: variable.parameter.fish punctuation.definition.option.long.separator.fish meta.string.unquoted.fish }
                end: (?=[\s;&)|<>])
                patterns:
                  - name: meta.string.unquoted.fish constant.numeric.fish
                    match: (?:[+-]?)(?:[0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)(?=$|[\s;&)|<>])

                  - include: '#parameter-patterns'

          - comment: Short option (parameter starting with one hyphen)
            name: meta.function-call.fish meta.parameter.option.short.fish variable.parameter.fish
            begin: (?:-)(?=[^\s;&)|<>])
            beginCaptures:
              '0': {name: punctuation.definition.option.short.fish meta.string.unquoted.fish}
            end: (?=[\s;&)|<>])
            patterns:
              - include: '#parameter-patterns'

          # Argument (parameter starting with no hyphens)
          - include: '#argument'

  parameter-patterns:
    comment: The typical substitutions, expansions, and escapes allowed anywhere in a parameter
    patterns:
      - include: '#command-substitution'

      - comment: Give variable expansion the unquoted string scope, since if it appears inside a string it gets the quoted string scope and we should mirror that
        name: meta.string.unquoted.fish
        begin: (?=\$)
        end: (?!\$)
        patterns:
          - include: '#variable-expansion'

      # Parameters are otherwise made of strings, either quoted or unquoted. The unquoted string rule handles character escapes and brace expansion
      - include: '#string'

  argument:
    comment: This rule must be entirely standalone because it is used in scopes where parameters starting with hyphens are explicitly interpreted as arguments rather than as options
    patterns:
      - comment: A parameter is a fundamental unit of a command call, defined as a sequence of non-operator characters separated by unescaped and unscoped whitespace
        begin: (?![\s;&)|<>^])
        comment: Begin arg if it does not precede whitespace or an operator
        end: (?=[\s;&)|<>])
        comment: End arg if it precedes whitespace or operators (excluding stderr redirect '^' due to a fish quirk)
        patterns:
          - comment: Process expansion only occurs if the '%' is at the front of the argument, and continues for the entire argument
            name: meta.function-call.fish meta.parameter.argument.process-expansion.fish
            begin: \%
            beginCaptures:
              '0': {name: meta.string.unquoted.fish punctuation.definition.process.fish}
            end: (?=[\s;&)|<>])
            patterns:
              - comment: Match special process names. By a convention that I'm making up, scope them as a type of variable
                name: meta.string.unquoted.fish variable.language.fish
                match: (?:self|last)(?=$|[\s;&)|<>])

              - include: '#parameter-patterns'

          - comment: Treat a sequence of integers (with possible sign and decimal separator) as a standalone constant. Do this separate to the #string-unquoted-patterns rule so we can ensure it is a string solely of numbers
            name: meta.function-call.fish meta.parameter.argument.numeric.fish meta.string.unquoted.fish constant.numeric.fish
            match: (?:[+-]?)(?:[0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)(?=$|[\s;&)|<>])

          - comment: This scope can be used by plugins to locate arguments which don't *start* with command substitution or variable expansion and may directly resolve to file paths. Of course, they could have command substitution or variable expansion further on in them, but looking ahead for that too is nontrivial
            name: meta.function-call.fish meta.parameter.argument.path.fish
            begin: (?![\s($])
            end: (?=[\s;&)|<>])
            patterns:
              - comment: Home directory expansion only occurs if the '~' is at the front of the argument, so check it first
                name: meta.string.unquoted.fish keyword.operator.tilde.fish
                match: \~

              - include: '#parameter-patterns'

          - comment: Use standard parameter patterns for whatever doesn't match the above
            name: meta.function-call.fish meta.parameter.argument.fish
            begin: (?!\s)
            end: (?=[\s;&)|<>])
            patterns:
              - include: '#parameter-patterns'

  pipeline:
    comment: The pipeline rule is nonterminating, meaning that it will not consume a *valid* control operator ('\n', ';', or '&'). It *will* consume control operators that appear in invalid locations
    patterns:
      - comment: This meta command acts as a unary operator on the command to the right, but it is only allowed at the beginning of a pipeline! Because it can't come after a pipe, it isn't in the more general #command-call-meta rule
        comment: If the command is followed by redirection, then the redirection is illegal so we have to open the scope and let it be caught by #pipeline. If the command is followed by any form of execution that just prints help text (ie, with an option or with an explicit or implicit newline), then don't open the scope
        begin: (?=(and|or)\b(?!\s*[\n;)-]))
        end: (?=[\n;&)])
        patterns:
          - comment: If the command is followed by an "&", then that's invalid
            begin: (and|or)\b(?!\s*[\n;)-])
            beginCaptures:
              '1': {name: meta.function-call.fish keyword.operator.word.fish meta.string.unquoted.fish}
            end: (?![^\n\S]|\&|\\\n)
            patterns:
              - include: '#separator-whitespace'

              - name: invalid.illegal.function-call.fish
                match: \&

              - include: '#line-continuation'

          - include: '#pipeline'

      - include: '#pipeline-segment'

  pipeline-segment:
    comment: The pipeline segment is agnostic of where it appears in the overall pipeline, but it does perform checks on what can appear after a pipe (if there is one) before it will recurse into itself
    patterns:
      - comment: Match operators (background, pipe, and redirect) which cannot start a pipeline because they must be consumed within or after a pipeline
        begin: (?=[&|]|(?:[0-9]+)?(?:<|>>?)|\^\^?)
        end: |-
          (?x)
          (?# Look ahead to ensure no more operators after whitespace)
          (?=\n)
          |
          (?!
            \s*
            (?:
              (?# Find a control operator)
              [\n;&)|]
            |
              (?# Find a pipe operator)
              (?:[0-9]+)?(?:<|>>?)|\^\^?
            )
          )
        patterns:
          - name: invalid.illegal.function-call.fish
            match: (?:[&|]|(?:[0-9]+)?(?:<|>>?)|\^\^?)

      - comment: Match a command which is illegal in the base scope
        name: invalid.illegal.function-call.fish
        match: (?:case|else|end)(?=[\s;&)|<>])

      - comment: Anonymous scope - A pipeline which may be one command call or multiple command calls linked by pipe operators ('|', '2>|', etc). The pipeline terminates at the first encounter of any control operator
        begin: (?=[^\s#])
        end: (?=[\n;&)])
        patterns:
          - comment: Anonymous scope - Match the command of a pipeline segment
            begin: |-
              (?x)
              (?# Negative lookahead for whitespace, comments, piping)
              (?!
                \s|\#|(?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
              )
            end: |-
              (?x)
              (?# Look ahead for operators after whitespace)
              (?=\s*
                (?:
                  (?# Find a control operator)
                  [\n;&)]
                |
                  (?# Find a pipe operator)
                  (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
                )
              )
            patterns:
              # Pick up the command call
              - include: '#command-call-meta'
              - include: '#command-call-standard'

          - comment: Anonymous scope - Match piping which may lead to a second command, and if it does recurse into #pipeline-segment again
            begin: |-
              (?x)
              (?# Look ahead for piping)
              (?=
                (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
              )
            end: (?=\s*[\n;&)])
            patterns:
              - comment: Match a pipe not followed by a command, hence a malformed segment of the pipeline. However, we make an exception for the case where a pipe is followed by another pipe, and match it further down
                begin: |-
                  (?x)
                  (?# Look ahead for piping followed by either control operators or redirection)
                  (?=
                    (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
                    \s*
                    (?:
                      $
                    |
                      [\n;&)]
                    |
                      (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)
                    )
                  )
                end: (?=\s*$|\s*[\n;&)])
                patterns:
                  - comment: If the pipeline would end implicitly (ie, with a newline or close parenthesis), then mark the pipe itself invalid
                    name: meta.function-call.fish invalid.illegal.operator.fish
                    match: (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|(?=\s*$|\s*[\n)])

                  - comment: If the pipeline would end with an explicit operator or encounter anything that we determined was invalid above, then mark the first set of piping as valid and everything beyond as invalid
                    name: meta.function-call.fish
                    match: |-
                      (?x)
                      (?# Consume valid piping; captures 1 2 3 4)
                      (?:([0-9]+)?(<|>>?)|(\^\^?))?(\|)
                      (?# Consume whitespace)
                      \s*
                      (?# Consume remainder; capture 5)
                      (.*)
                    captures:
                      '1': {name: meta.pipe.fish constant.numeric.file-descriptor.fish}
                      '2': {name: meta.pipe.fish keyword.operator.pipe.redirect.fish}
                      '3': {name: meta.pipe.fish keyword.operator.pipe.redirect.fish}
                      '4': {name: meta.pipe.fish keyword.operator.pipe.fish}
                      '5': {name: invalid.illegal.function-call.fish}

              - comment: Pick up a legitimate pipe
                comment: Pick up extra pipes after the first and mark them invalid, but in fish 3 it's valid syntax so don't get greedy with the highlighting
                name: meta.function-call.fish meta.pipe.fish
                match: (?:([0-9]+)?(<|>>?)|(\^\^?))?(\|)((?:\s*\|)+)?
                captures:
                  '1': {name: constant.numeric.file-descriptor.fish}
                  '2': {name: keyword.operator.pipe.redirect.fish}
                  '3': {name: keyword.operator.pipe.redirect.fish}
                  '4': {name: keyword.operator.pipe.fish}
                  '5': {name: invalid.illegal.function-call.fish}

              - comment: After a pipe can't be a comment
                name: meta.function-call.fish invalid.illegal.function-call.fish
                begin: \#
                end: (?=[\n)])

              - comment: After a pipe can't be an "and" or "or" that is taking another command as its parameters
                comment: This match should generally be pretty similar to the match which seeks a valid "and"/"or" in #pipeline, since the only difference is that here the same matched text is instead invalid. We can be a little simpler though, and not worry about marking an "&" as invalid since the word will be instead
                name: meta.function-call.fish invalid.illegal.function-call.fish
                match: (and|or)\b(?!\s*[\n;-])

              - include: '#separator-whitespace'

              - comment: Keep the scope going over escaped newlines and comments
                name: meta.function-call.fish
                begin: (?=\\\n)
                end: (?!\\\n)
                patterns:
                  - include: '#line-continuation'

              # Match the next command
              - include: '#pipeline-segment'

  command-call-meta:
    comment: Check if the command is a builtin which takes another command as parameters, ie, a meta command. However, ignore the command if it is taking an option, being backgrounded/piped, or in some cases redirected, as in such a case it should be picked up by #command-call-standard instead
    patterns:
      - comment: These meta commands force the parameter to behave as a standard command. They stop when their subcommand is piped. Notably, if the command is followed by redirection, then the redirection is legal and the command just prints its help text, so in that case we avoid opening this scope such that the command is caught elsewhere as a standard command
        begin: |-
          (?x)
          (builtin|command|exec)\b
          (?# Look ahead for control operations after whitespace)
          (?!\s*
            (?:
              (?# Find options)
              -
            |
              (?# Find simple control operations)
              [\n;&)|]
            |
              (?# Find redirection, which may be into a pipe but we don't care)
              (?:[0-9]+)?(?:<|>>?)|\^\^?
            )
          )
        beginCaptures:
          '1': {name: meta.function-call.fish support.function.fish meta.string.unquoted.fish}
        end: |-
          (?x)
          (?# Look ahead for control operations after whitespace)
          (?=\s*
            (?:
              (?# Find simple control operations)
              [\n;&)]
            |
              (?# Find piping)
              (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
            )
          )
        patterns:
          - include: '#separator-whitespace'
          - include: '#line-continuation'
          - include: '#command-call-standard'

      - comment: This meta command acts as a unary operator on the command to the right, which can also be a meta command. There is no restriction on where in a pipeline this command may appear
        comment: If the command is followed by redirection, then the redirection is illegal so we have to open the scope and let it be caught by #pipeline. If the command is followed by any form of execution that just prints help text (ie, with an option or with an explicit or implicit newline), then don't open the scope
        begin: (?=(not)\b(?!\s*[\n;)-]))
        end: (?=[\n;&)])
        patterns:
          - comment: If the command is followed by an "&", then that's invalid
            begin: (not)\b(?!\s*[\n;)-])
            beginCaptures:
              '1': {name: meta.function-call.fish keyword.operator.word.fish meta.string.unquoted.fish}
            end: (?![^\n\S]|\&|\\\n)
            patterns:
              - include: '#separator-whitespace'

              - name: invalid.illegal.function-call.fish
                match: \&

              - include: '#line-continuation'

          - include: '#pipeline'

  command-call-standard:
    comment: Check if the command is any other legal command, ie, a standard command
    patterns:
      - comment: Anonymous scope - A complete command comprising a name element and optional parameter, redirection, and comment elements
        begin: (?=\S)
        end: |-
          (?x)
          (?# Look ahead for operators)
          (?=
            (?:
              (?# Find a control operator)
              [\n;&)]
            |
              (?# Find a pipe operator)
              (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
            )
          )
        patterns:
          - comment: Anonymous scope - A name or block element. If a block is found, everything up to the `end` command is captured here. Note that redirection and process expansion can't start the element
            begin: (?![\s<>^%])
            end: (?=[\s;&)|<>])
            patterns:
              - comment: Look for block structures
                include: '#command-call-standard-block'

              - comment: Look for the alternate form of test, which uses a matching pair of '[' ']'
                begin: \[(?=[\s<>]|\\\n)
                beginCaptures:
                  '0': {name: meta.function-call.fish support.function.test.begin.fish}
                end: (\])|(\n|[;&)|].*)
                endCaptures:
                  '1': {name: meta.function-call.fish support.function.test.end.fish}
                  '2': {name: invalid.illegal.function-call.fish}
                patterns:
                  - include: '#separator-whitespace'
                  - include: '#line-continuation'
                  - include: '#parameter'
                  - include: '#redirection'

              - comment: Look for loop/function control commands. We perform no checking on the validity of their scope (because only allowing them in the correct scope won't work if they are used within if-blocks) or parameters (because fish does that during execution not parsing)
                match: (?:break|continue|return)(?=[\s;&)|<>])
                captures:
                  '0': {name: meta.function-call.fish keyword.control.conditional.fish}

              - comment: Anonymous scope - A generic name element
                begin: (?!\s)
                end: (?=[\s;&)|<>])
                patterns:
                  - comment: A command name can't contain a command substitution. We match the whole line if no closing parenthesis is found, or until the end of the command name if the command substitution gets closed
                    comment: fish would match the whole command name invalid if there was a command substitution anywhere in it, but we can't look ahead that effectively
                    name: invalid.illegal.function-call.fish
                    begin: (?=\()
                    end: (?=[\s;&)|<>])
                    patterns:
                      - begin: \(
                        end: \)|(?=[\n;&)|<>])

                  - comment: Otherwise, treat the element as a fraction of a name made of arbitrary strings (which breaks at an escaped newline)
                    name: meta.function-call.fish variable.function.fish
                    begin: (?!\s)
                    end: (?=[\s;&()|<>])
                    patterns:
                      - comment: The string scope explicitly forbids '$' so that the argument rule can pick it up as a variable expansion, but '$' is treated as a literal in command names, so we have to match it separately
                        name: meta.string.unquoted.fish
                        match: \$

                      - include: '#string'

          - comment: A command name can't begin with a process expansion operator (however the variable expansion operator '$' is allowed)
            name: meta.function-call.fish invalid.illegal.function-call.fish
            begin: \%
            end: (?=[\s;&)|<>])
            patterns:
              - include: '#string'

          # Redirection can immediately follow the command name, without whitespace separation
          - include: '#redirection'

          - comment: Anonymous scope - A list of parameter, redirection, or comment elements. We rely on this list being separated from the command name by whitespace
            begin: (?=[^\n\S]+)
            comment: Match any whitespace characters that aren't the newline
            end: |-
              (?x)
              (?# Look ahead for operators)
              (?=
                (?:
                  (?# Find a control operator)
                  [\n;&)]
                |
                  (?# Find a pipe operator)
                  (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
                )
              )
            patterns:
              - comment: A list of elements that does not start with an end-of-options parameter
                begin: (?!--[\s;&)|<>])
                end: |-
                  (?x)
                  (?# Look ahead for operators or the end of options)
                  (?=
                    (?:
                      (?# Find a control operator)
                      [\n;&)]
                    |
                      (?# Find a pipe operator)
                      (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
                    |
                      (?# Find a double hyphen)
                      --[\s;&)|<>]
                    )
                  )
                patterns:
                  - include: '#separator-whitespace'
                  - include: '#line-continuation'
                  - include: '#comment-internal-end'
                  - include: '#redirection'
                  - include: '#parameter'

              - comment: A list of elements that starts with an end-of-options parameter
                begin: (?=--[\s;&)|<>])
                end: |-
                  (?x)
                  (?# Look ahead for operators)
                  (?=
                    (?:
                      (?# Find a control operator)
                      [\n;&)]
                    |
                      (?# Find a pipe operator)
                      (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
                    )
                  )
                patterns:
                  - comment: Contain just the end-of-options parameter and give it the normal scope
                    begin: (?=--[\s;&)|<>])
                    end: (?=[\s;&)|<>])
                    patterns:
                      - include: '#parameter'

                  - comment: A list of elements (now forcibly using arguments)
                    begin: (?=\s)
                    end: |-
                      (?x)
                      (?# Look ahead for operators)
                      (?=
                        (?:
                          (?# Find a control operator)
                          [\n;&)]
                        |
                          (?# Find a pipe operator)
                          (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)?\|
                        )
                      )
                    patterns:
                      - include: '#separator-whitespace'
                      - include: '#line-continuation'
                      - include: '#comment-internal-end'
                      - include: '#redirection'
                      - include: '#argument'

  command-call-standard-block:
    patterns:
      - comment: Block commands cannot be backgrounded, piped, or redirected
        match: (begin|while|if|for|switch|function)\s*([&|<>])
        captures:
          '1': {name: meta.function-call.fish variable.function.fish}
          '2': {name: invalid.illegal.operator.fish}

      - comment: The begin command uniquely cannot be the last command in a command substitution
        match: (begin)\s*(\))
        captures:
          '1': {name: meta.function-call.fish variable.function.fish}
          '2': {name: invalid.illegal.operator.fish}

      - comment: The begin command can be alone on a line or followed by any command that doesn't start with a '-'. If a '-' is seen it shouldn't be treated as a block
        name: meta.block.begin.fish
        begin: begin(?=\s*$|\s*[\n;]|\s+[^\s-])
        beginCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        end: end(?=$|[\s;&)|<>])
        endCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        patterns:
          - include: $self

      - name: meta.block.while.fish
        begin: (?=while\s+[^\s;)-])
        comment: If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[\s;&)|<>])
        endCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        patterns:
          - comment: Anonymous scope - Capture the command name we know is there, include a single instance of a pipeline, and end when an operator is seen
            begin: while
            beginCaptures:
              '0': {name: meta.function-call.fish keyword.control.conditional.fish}
            end: (?=[\n;&)])
            patterns:
              - include: '#line-continuation'
              - include: '#pipeline'

          - comment: Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen
            comment: Todo - Let the $self scope handle invalid operators
            begin: (\n)|(;)|([&)])
            beginCaptures:
              '1': {name: meta.function-call.operator.fish}
              '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
              '3': {name: invalid.illegal.operator.fish}
            end: (?=end(?:$|[\s;&)|<>]))
            patterns:
              - include: $self

      - name: meta.block.if.fish
        begin: (?=if\s+[^\s;)-])
        comment: If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[\s;&)|<>])
        endCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        patterns:
          # Note that this internal scope does not treat the closing parenthesis as a control operator, because a command substitution can't end in the middle of a block
          - include: '#command-call-standard-block-if-internal'

      - name: meta.block.for-in.fish
        begin: (?=for\s+[^\s;)-])
        comment: If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[\s;&)|<>])
        endCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        patterns:
          - comment: Anonymous scope - Capture the command name we know is there, include a single instance of a parameter (the varname), and end when the whitespace after the varname is captured
            begin: (for)(\s+)
            beginCaptures:
              '1': {name: meta.function-call.fish keyword.control.conditional.fish}
              '2': {name: meta.function-call.fish}
            end: \s+
            endCaptures:
              '0': {name: meta.function-call.fish}
            patterns:
              - include: '#line-continuation' # Eats whitespace on next line!

              - include: '#parameter'

              - comment: Capture anything that a parameter explicitly rejects, which is mostly operators
                name: invalid.illegal.operator.fish
                match: \S+

          - comment: Line continuation is allowed between the varname and "in"
            include: '#line-continuation'

          - comment: Anonymous scope - Capture the command name which might be there, include an arbitrary number of arguments, and end when the control operator is seen
            begin: in(?=\s)
            beginCaptures:
              '0': {name: meta.function-call.fish keyword.control.conditional.fish}
            end: (?=[\n;&)])
            patterns:
              - include: '#separator-whitespace'
              - include: '#line-continuation'
              - include: '#comment-internal-end'
              - include: '#argument'

          - comment: Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen
            comment: Todo - Let the $self scope handle invalid operators
            begin: (\n)|(;)|([&)])
            beginCaptures:
              '1': {name: meta.function-call.operator.fish}
              '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
              '3': {name: invalid.illegal.operator.fish}
            end: (?=end(?:$|[\s;&)|<>]))
            patterns:
              - include: $self

          - comment: Anything beside line continuation, "in", or a control operator is invalid
            name: invalid.illegal.function-call.fish
            match: \S+?(?=[\s;&)])

          - include: '#separator-whitespace'

      - name: meta.block.switch.fish
        begin: (?=switch\s+[^\s;)-])
        comment: If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[\s;&)|<>])
        endCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        patterns:
          - comment: Anonymous scope - Match the valid part of the switch statement, then look for an invalid part
            begin: (?=switch)
            end: (?=[\n;&)])
            patterns:
              - comment: Anonymous scope - Capture the command name we know is there, include a single instance of a parameter (the value), and end when whitespace or a control operator is seen
                begin: (switch)(\s+)
                beginCaptures:
                  '1': {name: meta.function-call.fish keyword.control.conditional.fish}
                  '2': {name: meta.function-call.fish}
                end: (?=[\s;&)])
                patterns:
                  - include: '#line-continuation' # Eats whitespace on next line!
                  - include: '#parameter'

                  - comment: Capture anything that a parameter explicitly rejects, which is mostly operators
                    name: invalid.illegal.operator.fish
                    match: \S+

              - comment: Anonymous scope - Capture whitespace which might be there, match any non-control-operator strings as invalid, and end when a control operator is seen
                begin: \s+
                beginCaptures:
                  '0': {name: meta.function-call.fish}
                end: (?=[\n;&)])
                patterns:
                  - name: invalid.illegal.string.fish
                    match: \S+?(?=[\s;&)])

          - comment: Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen
            comment: Todo - Let the $self scope handle invalid operators
            begin: (\n)|(;)|([&)])
            beginCaptures:
              '1': {name: meta.function-call.operator.fish}
              '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
              '3': {name: invalid.illegal.operator.fish}
            end: (?=end(?:$|[\s;&)|<>]))
            patterns:
              - comment: Anonymous scope - Capture the command name which might be there, include an arbitrary number of arguments, and end when the control operator is captured
                begin: case(?=[\s;&)])
                beginCaptures:
                  '0': {name: meta.function-call.fish keyword.control.conditional.fish}
                comment: Todo - Double check this catches pipes, redirection into pipe, all that
                end: (\n)|(;)|([&)])
                endCaptures:
                  '1': {name: meta.function-call.operator.fish}
                  '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
                  '3': {name: invalid.illegal.operator.fish}
                patterns:
                  - include: '#separator-whitespace'
                  - include: '#line-continuation'
                  - include: '#comment-internal-end'
                  - include: '#argument'

                  - comment: Anything else (eg, redirection) is illegal
                    name: invalid.illegal.operator.fish
                    match: \S+?(?=[\s;&)])

              - include: $self

      - name: meta.block.function.fish
        begin: (?=function\s+[^\s;)-])
        comment: If the command name is followed by a valid string (not anything that closes the scope or a string starting with a '-') then open the scope
        end: end(?=$|[\s;&)|<>])
        endCaptures:
          '0': {name: meta.function-call.fish keyword.control.conditional.fish}
        patterns:
          - comment: Anonymous scope - Match the defined name of the function statement, then look for further parameters
            begin: (?=function)
            end: |-
              (?x)
              (?# Look ahead for operators)
              (?=
                (?:
                  (?# Find a control operator)
                  [\n;&)]
                |
                  (?# Find a redirect or pipe operator)
                  (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)\|?
                )
              )
            patterns:
              - comment: Anonymous scope - Capture the command name we know is there, include a single instance of a parameter (the value), and end when whitespace or a control operator is seen
                begin: (function)\s+
                beginCaptures:
                  '0': {name: meta.function-call.fish}
                  '1': {name: keyword.control.conditional.fish}
                end: (?=[\s;&)|<>])
                patterns:
                  - include: '#line-continuation' # Eats whitespace on next line!

                  - name: invalid.illegal.string.fish
                    begin: '[|<>]'
                    end: (?=[\s;&)])

                  - comment: Anonymous scope - Start when an escaped newline isn't present, and end when whitespace or an operator is seen
                    begin: (?!\\\n)
                    end: (?=[\s;&|<>])
                    patterns:
                      - comment: This is all the usual things a parameter is allowed to contain
                        name: meta.function-call.fish meta.parameter.argument.fish entity.name.function.fish
                        begin: (?![\s)])
                        end: (?=[\s;&)|<>])
                        patterns:
                          - include: '#parameter-patterns'

                      - comment: fish sees a closing parenthesis as mismatched, since command substitution is allowed
                        name: invalid.illegal.string.fish
                        match: \)

              - comment: Anonymous scope - Capture whitespace which might be there, then match anything normal for a command call, except redirections!
                begin: (?=[^\n\S])
                end: |-
                  (?x)
                  (?# Look ahead for operators)
                  (?=
                    (?:
                      (?# Find a control operator)
                      [\n;&)]
                    |
                      (?# Find a redirect or pipe operator)
                      (?:(?:[0-9]+)?(?:<|>>?)|\^\^?)\|?
                    )
                  )
                patterns:
                  - include: '#separator-whitespace'
                  - include: '#line-continuation'
                  - include: '#comment-internal-end'
                  - include: '#parameter'

          - comment: Anonymous scope - Capture the operator we know is there, include the base scope, and end when an `end` command is seen
            begin: (\n)|(;)|(?=[&)|]|(?:[0-9]+)?(?:<|>>?)|\^\^?)
            beginCaptures:
              '1': {name: meta.function-call.operator.fish}
              '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
            end: (?=end(?:$|[\s;&)|<>]))
            patterns:
              - include: $self

  command-call-standard-block-if-internal:
    comment: The acceptable structure internal to an if-end block can be represented recursively because anonymous scopes nest silently. If an `else` without a following `if` is seen, then further `else` commands will be correctly marked as invalid. This is a lot of work just to get that extra little bit of functionality :)
    patterns:
      - comment: Anonymous scope - Capture an `if` and the command up to the control operator, then capture from the control operator indefinitely
        begin: (?=if(?:\s*\n|\s+[^\s;]))
        end: (?=end(?:$|[\s;&)|<>]))
        patterns:
          - comment: Anonymous scope - Match the command name we know is there, include a single instance of a pipeline, and end when a control operator is seen
            begin: if
            beginCaptures:
              '0': {name: meta.function-call.fish keyword.control.conditional.fish}
            end: (?=[\n;&])
            patterns:
              - include: '#line-continuation'
              - include: '#pipeline'

          - comment: Anonymous scope - Match the operator we know is there, then include the base scope or an `else` structure
            begin: (\n)|(;)|(&)
            beginCaptures:
              '1': {name: meta.function-call.operator.fish}
              '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
              '3': {name: invalid.illegal.operator.fish}
            end: (?=end(?:$|[\s;&)|<>]))
            patterns:
              - comment: Anonymous scope - Capture an `else` up to the control operator or the start of an `if` structure, then match from the control operator indefinitely or match an `if` structure
                begin: (?=else\s*[\s;])
                end: (?=end(?:$|[\s;&)|<>]))
                patterns:
                  - comment: Anonymous scope - Match the `else` we know is there and any comment, and mark anything besides an `if` as illegal
                    begin: else(?=\s*[\s;])
                    beginCaptures:
                      '0': {name: meta.function-call.fish keyword.control.conditional.fish}
                    end: (?=[\n;&]|if(?:\s*\n|\s+[^\s;]))
                    patterns:
                      - include: '#separator-whitespace'
                      - include: '#line-continuation'
                      - include: '#comment-internal-end'

                      - comment: Anything else is illegal
                        name: invalid.illegal.string.fish
                        match: \S+?(?=[\s;&])

                  - comment: Anonymous scope - Match the operator which will be there if no `if` was seen, then include the base scope which marks further `else` commands as invalid
                    begin: (\n)|(;)|(&)
                    beginCaptures:
                      '1': {name: meta.function-call.operator.fish}
                      '2': {name: meta.function-call.operator.fish keyword.operator.control.fish}
                      '3': {name: invalid.illegal.operator.fish}
                    end: (?=end(?:$|[\s;&)|<>]))
                    patterns:
                      - include: $self

                  # Match the `if` structure which will be there if no operator was seen
                  - include: '#command-call-standard-block-if-internal'

              - include: $self

  command-substitution:
    patterns:
      - comment: Capture "(...)" or "(...)[...]"
        begin: (?=\()
        end: (?![\(\[])
        patterns:
          - name: meta.parens.command-substitution.fish
            begin: \(
            beginCaptures:
              '0': {name: punctuation.section.parens.begin.fish}
            end: \)
            endCaptures:
              '0': {name: punctuation.section.parens.end.fish}
            patterns:
              - comment: The inside of a command substitution is indistinguishable from a global scope
                include: '$self'

          - include: '#index-expansion'

  comment-external:
    patterns:
      - comment: A full or inline comment outside of any command call
        name: comment.line.external.fish
        begin: \#
        beginCaptures:
          '0': {name: punctuation.definition.comment.fish}
        end: \n

  comment-internal-end:
    patterns:
      - comment: An inline comment at the end of a command call. Does not consume the newline, thus allowing the command call to capture it and end
        name: comment.line.internal.end.fish
        begin: \#
        beginCaptures:
          '0': {name: punctuation.definition.comment.fish}
        end: (?=\n)

  index-expansion:
    patterns:
      - name: meta.brackets.index-expansion.fish
        comment: Note also that command substitution can only have a single index expansion
        begin: \[
        beginCaptures:
          '0': {name: punctuation.section.brackets.begin.fish}
        end: \]
        endCaptures:
          '0': {name: punctuation.section.brackets.end.fish}
        comment: The number of index expansion parameter lists `[...]` should always be less than or equal to the number of variable expansion operators `$`. Unfortunately, we can do nothing to moderate that with this syntax schema; with a *.sublime-syntax and a scope stack it could be done. As it stands, "$$foo[...]" is the deepest that we can accurately highlight
        comment: In other words, the anonymous scope which contains the variable and the index expansion parameter list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack. Our workaround is to allow an infinite number of these and hope the user can keep track of when there are too many
        patterns:
          - name: keyword.operator.range.fish
            match: \.\.

          - include: '#command-substitution'

          - include: '#variable-expansion'

          - include: '#string-quoted'

          - comment: There's no need to apply meta.string.unquoted to anything inside of an index expansion, as if it needs to be applied then it would have been handled already. The fact index expansion can appear inside of quotes (after a variable expansion) makes it tricky to decide what is or isn't "unquoted"
            name: constant.numeric.fish
            match: (?:[+-]?[0-9]+)(?=[\s;&)|<>]|\]|\.\.)

          - comment: Anything else is invalid
            name: invalid.illegal.index.fish
            match: \S

  line-continuation:
    comment: This rule should be included anywhere that escaping a newline and adding an arbitrary number of comment lines is permitted (which is pretty much everywhere in fish)
    patterns:
      - comment: Consume any number of alternating escaped newlines and lines which have nothing on them but comments
        begin: (?=\\\n)
        end: (?=\n)|^(?![\s\#\\])|\s(?![\s\#])
        comment: End when an unescaped newline is seen, the first character of a line isn't whitespace or a comment character or the escaped newline itself, or if the next character after some consumed whitespace isn't more whitespace or a comment character
        patterns:
          - name: constant.character.escape
            match: \\\n

          - name: comment.line.continuation.fish
            begin: \#
            beginCaptures:
              '0': {name: punctuation.definition.comment.fish}
            end: \n

  redirection:
    patterns:
      - comment: This redirection pattern connects a file descriptor (either explicit or implied) to another file descriptor. As the '&' is necessary to denote the target file descriptor, this is a more strict pattern match and must be attended to first
        begin: (?=(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])\&)
        comment: Begin at any of the redirections valid for a file descriptor (the '&' must be present). Note that the stderr redirect operator '^' cannot be preceded by a file descriptor. The parameter and argument rules are in charge of preventing '^' being treated as a redirection when it appears in the middle of a word
        end: (?=[\s;&)|]|(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])(?![&<>^]))
        comment: End at anything that would end a parameter, including redirections *if* they are *not* this same type of redirection (ie, have an '&'), in which case this scope stays open and we match the next one. The negative lookahead for <>^ at the end is to keep ST2 happy (not hanging)
        patterns:
          - begin: (?:([0-9]+)(<|>>|>)|(>>|\^\^|[<>^]))(\&)\s*
            beginCaptures:
              '0': {name: meta.function-call.fish meta.redirection.fish}
              '1': {name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish}
              '2': {name: keyword.operator.redirect.fish}
              '3': {name: keyword.operator.redirect.fish}
              '4': {name: keyword.operator.redirect.dereference.fish}
            end: (\&.*$)|(?![&\\])
            endCaptures:
              '0': {name: meta.function-call.fish meta.redirection.fish}
              '1': {name: invalid.illegal.file-descriptor.fish}
            comment: We have to try and catch an '&' here because if it is seen by the outer end match then it will be considered a valid operator and the redirection scope will immediately terminate
            patterns:
              - include: '#line-continuation' # Eats whitespace on next line

          - include: '#line-continuation'

          - comment: Evaluates to a string which may be an integer
            name: meta.function-call.fish meta.redirection.fish
            begin: (?=\()
            end: (?!\()
            patterns:
              - include: '#command-substitution'

          - comment: Evaluates to a string which may be an integer
            name: meta.function-call.fish meta.redirection.fish
            begin: (?=\$)
            end: (?!\$)
            patterns:
              - include: '#variable-expansion'

          - comment: May be a quoted integer, which is allowed
            name: meta.function-call.fish meta.redirection.fish
            begin: (?=['"])
            end: (?!['"])
            patterns:
              - include: '#string-quoted'

          - name: meta.function-call.fish meta.redirection.file-descriptor.fish meta.string.unquoted.fish constant.numeric.file-descriptor.fish
            match: (?:[0-9]+)(?=$|[\s;&)|<>])
          - name: meta.function-call.fish meta.redirection.file-descriptor.fish meta.string.unquoted.fish keyword.operator.redirect.close.fish
            match: (?:-)(?=$|[\s;&)|<>])

          - comment: Anything else is illegal
            name: meta.function-call.fish meta.redirection.fish invalid.illegal.file-descriptor.fish
            match: (?:\S+.*)$

      - comment: This redirection pattern connects a file descriptor (either explicit or implied) and a file path
        begin: (?=(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])\??)
        comment: Begin at any of the redirections valid for a file path (the '?' may optionally be used to prevent clobber). See above comments on stderr redirect operator '^'
        end: (?=[\s;&)|]|(?:[0-9]+(?:<|>>|>)|>>|\^\^|[<>^])[&|]) # todo: watch out for redirect into pipe?
        comment: End at anything that would end a parameter, including redirections *if* they are *not* this same type of redirection (ie, redirection into file descriptor, or into pipe), in which case this scope stays open and we match the next one
        patterns:
          - begin: (?:([0-9]+)(<|>>|>)|(>>|\^\^|[<>^]))(\?)?\s*
            beginCaptures:
              '0': {name: meta.function-call.fish meta.redirection.fish}
              '1': {name: meta.string.unquoted.fish constant.numeric.file-descriptor.fish}
              '2': {name: keyword.operator.redirect.fish}
              '3': {name: keyword.operator.redirect.fish}
              '4': {name: keyword.operator.redirect.clobber-test.fish}
            end: ((?:[&?]|[0-9]*[<>^]).*$)|(?![&?<>^])
            endCaptures:
              '0': {name: meta.function-call.fish meta.redirection.fish}
              '1': {name: invalid.illegal.path.fish}
            comment: We have to try and catch bad operators here because if they are seen by the outer end match then they will be considered valid and the redirection scope will immediately terminate
            patterns:
              - include: '#line-continuation' # Eats whitespace on next line

          - include: '#line-continuation'

          - comment: A redirection path cannot contain brace expansion
            name: meta.function-call.fish meta.redirection.fish invalid.illegal.path.fish
            begin: \{|(?=\})
            end: '[\s;&)|}]'

          - comment: A redirection path cannot contain wildcard expansion
            name: meta.function-call.fish meta.redirection.fish invalid.illegal.path.fish
            match: '[*?]'

          - comment: Check for characters which are associated with redirection, so path cannot begin with them
            name: meta.function-call.fish meta.redirection.fish invalid.illegal.path.fish
            match: (?:[&?]|[0-9]*[<>^]).*$

          # We reserve the meta.redirection.path scope only for redirection paths which may represent literal paths

          - name: meta.function-call.fish meta.redirection.path.fish meta.string.unquoted.fish keyword.operator.tilde.fish
            match: \~

          - name: meta.function-call.fish meta.redirection.path.fish
            begin: (?![\s;&()|<>${}*?])
            end: (?=[\s;&()|<>${}*?])
            comment: Use strings to build a file path, but break out if any invalid elements or elements that wouldn't form a literal path are encountered
            patterns:
              - include: '#string-quoted'

              - comment: Should use the same patterns as the above begin/end, but also add the quotes so the #string-quoted rule can handle quoted strings
                name: meta.string.unquoted.fish
                begin: (?![\s;&()|<>${}*?]|['"])
                end: (?=[\s;&()|<>${}*?]|['"])
                patterns:
                  - include: '#string-unquoted-patterns-escapes'

          - comment: A raw path cannot begin with '(' since this undergoes command substitution
            name: meta.function-call.fish meta.redirection.fish
            begin: (?=\()
            end: (?!\()
            patterns:
              - include: '#command-substitution'

          - comment: A raw path cannot begin with '$' since this undergoes variable expansion
            comment: We also make sure that variable expansion is scoped as an unquoted string, since if it appears inside quotes then it gets scoped as a quoted string and we should mirror that
            name: meta.function-call.fish meta.redirection.fish meta.string.unquoted
            begin: (?=\$)
            end: (?!\$)
            patterns:
              - include: '#variable-expansion'

  string:
    patterns:
      - include: '#string-quoted'
      - include: '#string-unquoted'

  string-quoted:
    patterns:
      - name: string.quoted.single.fish
        begin: \'
        beginCaptures:
          '0': {name: punctuation.definition.string.begin.fish}
        end: \'
        endCaptures:
          '0': {name: punctuation.definition.string.end.fish}
        patterns:
          - comment: Only accepted escapes are \' and \\
            name: constant.character.escape.fish
            match: \\[\'\\]

      - name: string.quoted.double.fish
        begin: \"
        beginCaptures:
          '0': {name: punctuation.definition.string.begin.fish}
        end: \"
        endCaptures:
          '0': {name: punctuation.definition.string.end.fish}
        patterns:
          - comment: Only accepted escapes are \<newline>, \", \\, and \$
            name: constant.character.escape.fish
            match: \\[\n\"\\$]

          - comment: Variable expansion is the only expansion accepted
            include: '#variable-expansion'

  string-unquoted:
    patterns:
      - name: meta.string.unquoted.fish
        begin: (?![\s;&()|<>'"$])
        comment: Begin unquoted string if not whitespace, control operator, quoted string, or variable expansion
        end: (?=[\s;&()|<>'"$])
        comment: End unquoted string at anything that can't be in one
        patterns:
          - include: '#string-unquoted-patterns'

  string-unquoted-patterns:
    comment: Describe contents of an unquoted string separately for ease of recursion
    patterns:
      - include: '#string-unquoted-patterns-escapes'

      - name: meta.braces.brace-expansion.fish
        begin: \{
        beginCaptures:
          '0': {name: punctuation.section.braces.begin.fish}
        end: (\})|(\n|[;&)|].*)
        endCaptures:
          '1': {name: punctuation.section.braces.end.fish}
          '2': {name: invalid.illegal.punctuation.section.fish}
        patterns:
          - name: punctuation.section.braces.separator.fish
            match: \,

          - include: '#command-substitution'

          - include: '#variable-expansion'

          - comment: Unescaped spaces aren't allowed, as technically that separates the braces into two separate arguments. Don't consume a newline though, so the scope end capture can get it
            name: invalid.illegal.whitespace.fish
            match: (?:[^\n\S]+)

          # Manually recreate the string rule with a numeric match, extra logic in unquoted strings, and don't repeat the meta.string.unquoted scope
          - include: '#string-quoted'
          - name: constant.numeric.fish
            match: (?:[+-]?)(?:[0-9]+\.?[0-9]*|[0-9]*\.?[0-9]+)(?=$|[\s;&)|<>]|\}|\,)
          - begin: (?![\s;&)|<>'"])
            end: (?=[\s;&)|<>'"]|\}|\,)
            comment: Begin/end string as before with the addition of breaking at a '}' or ','
            patterns:
              - name: constant.character.escape.fish
                match: \\\,
              - include: '#string-unquoted-patterns'

      - name: meta.wildcard-expansion.fish
        match: (\*\*)|(\*)|(\?)
        captures:
          '1': {name: keyword.operator.double-star.fish}
          '2': {name: keyword.operator.single-star.fish}
          '3': {name: keyword.operator.question-mark.fish}

  string-unquoted-patterns-escapes:
    patterns:
      - comment: This list follows the order given in official fish documentation. Technically '~' and '%' only need escaping if they appear at the front of a parameter. If they are escaped within a parameter, then fish does not *highlight* the escape, however it does silently *parse* the escape and the backslash is removed before the parameter is passed to the command. So, we highlight these escapes as well since they are actually treated as valid escapes by fish
        name: constant.character.escape.fish
        match: |-
          (?x)
          \\[abefnrtv $\\*?#(){}\[\]<>^&|;"']
          |
          \\[~%]
          |
          \\[xX][0-9A-Fa-f]{1,2}
          |
          \\[0-7]{1,3}
          |
          \\u[0-9A-Fa-f]{1,4}
          |
          \\U[0-9A-Fa-f]{1,8}
          |
          \\c[?-~]

      - comment: Just for convenience we separate the newline escape
        name: constant.character.escape.fish
        match: \\\n

  variable-expansion:
    patterns:
      - include: '#variable-expansion-illegal'

      - comment: Capture "$foo" or "$foo[]" or "$$foo[][]" etc
        name: meta.variable-expansion.fish
        begin: (?=\$)
        end: (?=[^\$\w\[])
        patterns:
          # Match any depth of recursive variable expansions
          - name: variable.other.fish
            begin: \$
            beginCaptures:
              '0': {name: punctuation.definition.variable.fish}
            end: (?=[^\$\w])
            patterns:
              - include: '#variable-expansion-illegal'
              - include: '#variable-expansion-simple'

          # Match any number of consecutive index expansions
          - include: '#index-expansion'

  variable-expansion-simple:
    comment: Describe variable expansion that has no index expansion separately
    patterns:
      - name: variable.other.fish
        begin: \$
        beginCaptures:
          '0': {name: punctuation.definition.variable.fish}
        end: (?=[^\$\w])
        patterns:
          - include: '#variable-expansion-illegal'
          - include: '#variable-expansion-simple'

  variable-expansion-illegal:
    comment: Describe illegal variable expansions separately
    patterns:
      - comment: A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted
        name: invalid.illegal.variable-expansion.fish
        match: \$(?:(?=[,'"\]}\s;&)|])|[^\w\$][^$,'"\]}\s;&)|]*)

firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|case|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(case|else|end)\b)
keyEquivalent: ^~S
