# [PackageDev] target_format: plist, ext: tmLanguage
name: Shell Script Improved (fish)
scopeName: source.fish
fileTypes: [fish]
uuid: f9278d07-f7c1-4a9b-9581-ebcbc050fbfb

# Style guide:
# - keyword.control.conditional is applied to all control keywords that are actually words (if, else, end, function, etc.)
# - support.function is applied to any fish builtins that we have to treat uniquely, however variable.function is used for everything else including other shell builtins
# - constant.character.escape is used for the backslash at the end of a line which causes line continuation because technically that backslash is "escaping" the literal newline which appears in the unquoted string environment which the shell assumes you are in. In this sense, the backslash is indeed an escape character
# - constant.character.escape is used for \x?? and \0?? escape codes rather than constant.numeric.{hex,octal} because even though the user inputs a numeric value in hex or octal, the codes serve the purpose of making characters not numbers
# - Individual arguments in function calls do not get the variable.parameter label because that swiftly becomes the overwhelming majority of all words in a program
# - By analogy to the recommendation that `meta.function.php meta.function.parameters.php` should never occur, we use a single `meta.function-call` scope and name the argument scope `meta.argument` not `meta.function-call.argument`. Furthermore, a single `meta.function-call` scope continues from the first command name until the consumption of a ';', '&', or '\n'. The same scope continues through '|' because we have no other way to ensure that a command follows a '|'
# - Every character outside of comments should be scoped as `meta.string.unquoted`, `string.quoted.single`, or `string.quoted.double`. Furthermore, there is no concept of an unquoted string inside a quoted string or vice-versa
# - The order of operators in expressions is (by invented convention): newline '\n', whitespace '\s' (includes newline), ';', '&', '(', ')', '|', '<', '>', '^'

patterns:
  - comment: Base scope - Pick up '#' and "\\\n" before command-call sees them
  - include: '#comment-external'
  - include: '#line-continuation'

  - comment: A command can't begin with a close parenthesis. We match this so exclusively early because the command chain scope will end immediately if the close parenthesis is seen by its lookahead
    comment: In an ideal world, command-call-standard would be performing this match because fish highlights the strings which follow as arguments. But we can't do that
    name: meta.function-call.fish invalid.illegal.function-call.fish
    begin: \)
    end: (?=[\s;&)|<>])

  - comment: Anonymous scope - Base scope command chain (up until a newline or ';')
    begin: (?=\S)
    end: \n|(;)|(?=\))
    endCaptures:
      '1': {name: meta.function-call.operator.fish keyword.operator.fish}
    patterns:
      - comment: Match an operation which cannot start a command chain (because it is consumed by the command chain when it appears further within it). These are simple control operators and redirections (which conveniently also matches redirection-into-pipe)
        name: invalid.illegal.operator.fish
        match: (?:[&|]|(?:[0-9]+)?(?:<|>|>>))

      - comment: Anonymous scope - Base scope command chain (up until an '&')
        comment: The reason we match the '&' in a different way is the ';' can be alone on a line, while we must explicitly require that the '&' comes after a command
        begin: (?=\S)
        end: (?=[\n;)])|(&)
        endCaptures:
          '1': {name: meta.function-call.operator.fish keyword.operator.fish}
        patterns:
          - include: '#command-chain'

repository:
  argument:
    patterns:
      - comment: An argument is a fundamental unit of a command call, defined as a sequence of non-control-operator characters separated by unescaped and unscoped whitespace
        name: meta.argument.fish
        begin: (?![\s;&)|<>^])
        comment: Begin arg if it does not precede whitespace or a control operator
        end: (?=[\s;&)|<>])|(?=\\\n)
        comment: End arg if it precedes whitespace or control operators (including stdin/stdout redirection but not stderr due to a fish quirk), or an escaped newline (which line-continuation should take care of)
        patterns:
          - comment: Home directory expansion only occurs if the '~' is at the front of the argument
            name: meta.string.unquoted.fish meta.home-directory-expansion.fish keyword.operator.tilde.fish
            match: \~

          - comment: Process expansion only occurs if the '%' is at the front of the argument, and continues for the entire argument
            name: meta.process-expansion.fish
            begin: \%
            beginCaptures:
              '0': {name: meta.string.unquoted.fish punctuation.definition.process.fish}
            end: (?=[\s;&)|<>])
            patterns:
              - comment: Match special process names. By a convention that I'm making up, scope them as a type of variable
                name: meta.string.unquoted.fish variable.language.fish
                match: (?:self|last)(?=[\s;&)|])

              - comment: An escaped newline during a process expansion cannot be used to insert comments so consume it and let the process expansion continue on the next line
                name: constant.character.escape.fish
                match: \\\n

              - include: '#command-substitution'
              - include: '#variable-expansion'
              - include: '#string'

          - comment: Arguments are otherwise made of strings, either quoted or unquoted. The unquoted string rule handles numerics, character escapes, command substitutions, and brace/variable/process expansions. These scopes consume the remainder of the argument
            begin: (?!\s)
            end: (?=[\s;&)|<>])|(?=\\\n)
            patterns:
              - include: '#command-substitution'

              - comment: Give the variable expansion the unquoted string scope
                name: meta.string.unquoted.fish
                begin: (?=\$)
                end: (?!\$)
                patterns:
                  - include: '#variable-expansion'

              - include: '#string'

  command-chain:
    comment: The command-chain rule is nonterminating, meaning that it will not consume a newline, ';', or '&'
    patterns:
      - comment: Match an operation which cannot start a command chain (because it is consumed by the command chain when it appears further within it). These are simple control operators and redirections (which conveniently also matches redirection-into-pipe)
        comment: Todo - Restructure command-chain so that this match isn't duplicated from the base scope. Might require the unary operator commands to become an explicit recursive match (though we tried this once and it was more complicated than anything should be)
        name: invalid.illegal.operator.fish
        match: (?:[&|]|(?:[0-9]+)?(?:<|>|>>))

      - comment: Match a command which acts as a unary operator on the command to the right. Neglect the match if it is taking the one valid option argument these commands accept. Allow the match if there is a scope-ending operation after the command name
        name: meta.function-call.fish keyword.operator.word.fish
        match: (and|not|or)(?=\s+(?!-h|--help)|[;&)|<>])

      - comment: Match a command which is illegal in the base scope
        name: invalid.illegal.function-call.fish
        match: (?:case|else|end)(?=[\s;&)|<>])

      - comment: Anonymous scope - Command chain. Define a command chain as either one command call, or multiple command calls linked by piping ('|', '2>|', etc). The chain terminates at the first encounter of any other control operator (newline, ';', '&') or the implied newline of the closing parenthesis of a command substitution
        # name: anon-command-chain
        begin: (?=[^\s#])
        end: (\s*)(?=[\n;&)])
        endCaptures:
          '1': {name: meta.function-call.fish}
        patterns:
          - comment: Match one command, which may start with any non-whitespace character. If it starts with piping however, perform checks to ensure it is valid. A command call ends at any control operation including piping
            name: meta.function-call.fish
            begin: (?=\S)
            end: |-
              (?x)
              (?# Look ahead for control operations after whitespace)
              (?=\s*
                (?:
                  (?# Find simple control operations)
                  [\n;&)]
                |
                  (?# Find piping)
                  (?:(?:[0-9]+)?(?:<|>|>>))?\|
                )
              )
            patterns:
              - comment: If there's no command call after the pipe and the command chain would end quietly, then mark the pipe invalid
                comment: We can't lookahead to find a close parenthesis because we want that close parenthesis to be caught and marked invalid. The downside is that this means a pipe at the end of the inside of a command substitution will not be marked invalid, but it turns out the fish parser doesn't do that either!
                name: invalid.illegal.operator.fish
                match: (?:(?:[0-9]+)?(?:<|>|>>))?\|(?=\s*\n)

              - comment: If there's no command call after the pipe and the command chain would end with an operator, then mark the next control operator (and beyond) as invalid
                match: |-
                  (?x)
                  (?# Consume valid piping; groups 1 2 3)
                  (?:([0-9]+)?(<|>|>>))?(\|)
                  (?# Consume whitespace)
                  \s*
                  (?# Look ahead for control operations)
                  (?=
                    (?:
                      (?# Find simple control operations)
                      [;&]
                    |
                      (?# Find piping)
                      (?:(?:[0-9]+)?(?:<|>|>>))?\|
                    )
                  )
                  (?# Consume control operations and beyond; group 4)
                  (.*)$
                captures:
                  '1': {name: meta.pipe.fish constant.numeric.file-descriptor.fish}
                  '2': {name: meta.pipe.fish keyword.operator.redirect.fish}
                  '3': {name: meta.pipe.fish keyword.operator.pipe.fish}
                  '4': {name: invalid.illegal.function-call.fish}

              - name: meta.pipe.fish
                match: (?:([0-9]+)?(<|>|>>))?(\|)
                captures:
                  '1': {name: constant.numeric.file-descriptor.fish}
                  '2': {name: keyword.operator.redirect.fish}
                  '3': {name: keyword.operator.pipe.fish}

              - include: '#line-continuation'
              - include: '#command-call-meta'
              - include: '#command-call-block'
              - include: '#command-call-standard'

      - comment: Pick up a comment that comes after an '&' or otherwise sneaks into the scope
        include: '#comment-internal-end'

  command-call-meta:
    patterns:
      - comment: Check if the command is a builtin which takes another command as arguments, ie, a meta command. Because these commands could take options or be backgrounded/piped -- in which case they do not behave as meta commands -- look ahead to ensure that no options or control operators are found. Note also that a meta command forces its argument to behave as a standard command
        begin: (builtin|command|exec)\b(?!\s+[-&|])
        beginCaptures:
          '1': {name: support.function.fish}
        end: (?=[\n;&)|])
        patterns:
          - include: '#line-continuation'
          - include: '#command-call-block'
          - include: '#command-call-standard'

  command-call-block-rewrite:
    patterns:
      - comment: Block commands cannot be backgrounded, piped, or redirected
        match: (begin|while)\s*([&|<>])
        captures:
          '1': {name: variable.function.fish}
          '2': {name: invalid.illegal.operator.fish}

      - comment: The begin command uniquely cannot be the last command in a command substitution
        match: (begin)\s*(\))
        captures:
          '1': {name: variable.function.fish}
          '2': {name: invalid.illegal.operator.fish}

      - comment: The begin command can be alone on a line or followed by any command that doesn't start with a '-'. If a '-' is seen it shouldn't be treated as a block
        name: meta.block.begin.fish
        begin: begin(?=\s*[\n;]|\s+[^\s-])
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: end(?=[\s;&)|<>])
        endCaptures:
          '0': {name: keyword.control.conditional.fish}
        patterns:
          - include: $self

      - name: meta.block.while.fish
        begin: (?=while\s+[^\s;)-])
        comment: If the command name is followed by a valid command (not anything that closes the scope or a command starting with a '-') then open the scope
        end: end(?=[\s;&)|<>])
        endCaptures:
          '0': {name: keyword.control.conditional.fish}
        patterns:
          - comment: Capture the command name we know is there, include a single instance of a command chain, and end when an operator is seen
            begin: while
            beginCaptures:
              '0': {name: keyword.control.conditional.fish}
            end: \s*(?=[\n;&)])
            patterns:
              - include: '#line-continuation'
              - include: '#command-chain'

          - comment: Capture the operator we know is there, include the base scope, and end when an `end` command is seen
            begin: \n|(;)|([&)])
            beginCaptures:
              '1': {name: keyword.operator.fish}
              '2': {name: invalid.illegal.operator.fish}
            end: (?=end[\s;&)|<>])
            patterns:
              - include: $self

  command-call-block:
    patterns:
      - name: meta.block.if.fish
        begin: \b(if)\b(?!\s*(-|&|\|))
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (end)
        endCaptures:
          '1': {name: keyword.control.conditional.fish}
        patterns:
          - comment: Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call
            name: keyword.control.conditional.fish
            match: \b(else(\s*if)?)\b
          - include: '$self'

      - name: meta.block.for-in.fish
        begin: \b(for)\b(?!\s*(-|&|\|))
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (end)(\s*([;&]))?
        endCaptures:
          '1': {name: keyword.control.conditional.fish}
          '3': {name: keyword.operator.fish}
        patterns:
          - begin: (?<=for)
            end: (?<=\w)(?=\W)
            patterns:
              - comment: Treat the varname like an argument
              - include: '#line-continuation'
              - include: '#argument'

          - begin: \b(in)\b
            beginCaptures:
              '0': {name: keyword.control.conditional.fish}
            end: (?=;)|\n
            patterns:
              - include: '#line-continuation'
              - include: '#comment-internal-end'

              - comment: Treat the list as arguments
              - include: '#argument'

          - include: '#loop-control-command'
          - include: '$self'

      - name: meta.block.switch.fish
        begin: \b(switch)\b(?!\s*(-|&|\|))
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (end)(\s*([;&]))?
        endCaptures:
          '1': {name: keyword.control.conditional.fish}
          '3': {name: keyword.operator.fish}
        patterns:
          - name: meta.block.switch.value.fish
            begin: (?<=switch)
            end: \n|(;)
            endCaptures:
              '1': {name: keyword.operator.fish}
            comment: Value ends at a newline or ';'
            patterns:
              - include: '#line-continuation'
              - include: '#comment-internal-end'
              - include: '#argument'

          - name: meta.block.switch.case.fish
            begin: \b(case)\b
            beginCaptures:
              '0': {name: keyword.control.conditional.fish}
            end: (?=\b(case|end)\b)
            comment: Case block ends before a new case or the end of the switch block
            patterns:
              - name: meta.block.switch.case.wildcard.fish
                begin: (?<=case)
                end: \n|(;)
                endCaptures:
                  '1': {name: keyword.operator.fish}
                comment: Wildcard ends at a newline or ';'
                patterns:
                  - include: '#line-continuation'
                  - include: '#comment-internal-end'
                  - include: '#argument'

              - include: '$self'

          - include: '#comment-external'

      - name: meta.block.function.fish
        begin: \b(function)\b(?!\s+(&|\|))
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (end)(\s*([;&]))?
        endCaptures:
          '1': {name: keyword.control.conditional.fish}
          '3': {name: keyword.operator.fish}
        patterns:
          - begin: (?<=function)
            end: \n|(;)
            endCaptures:
              '1': {name: keyword.operator.fish}
            comment: Name and options end at a newline or ';'
            patterns:
              - begin: (?<=function)\s+
                end: (?<=\S|\\ )\s*(?=[\S\n;])
                comment: Detect the region from just after the `function` command to between the defined function name and the argument or control operators which follow it. Note that we have to account for the fact the defined function name may end in an escaped space
                patterns:
                  - comment: The function name may be given using any means that is valid for a command call
                    match: (?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]<>^&;|"']|(?<=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()<>&|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]<>^&;|"'xXuUc])|(?<=\S|\\ )\\\n|(?<=\S|\\ )[~%#])+)+
                    name: entity.name.function.fish

                  - comment: We can't read across lines, so this is needed to catch an escaped newline at the begin of a defined function name
                  - include: '#line-continuation'

                  - include: '#comment-internal-end'

              - comment: The rest of the patterns are the typical elements of a standard command-call, which is what the `function` command adheres to
              - include: '#line-continuation'
              - include: '#comment-internal-end'
              - include: '#argument'

          - begin: \b(return)\b(?!\s+(-))
            beginCaptures:
              '1': {name: keyword.control.conditional.fish}
            end: (?=\)|;)|\n|(&|\|)
            endCaptures:
              '1': {name: keyword.operator.fish}
            comment: The `return` command can't accept flags
            patterns:
              - include: '#line-continuation'
              - include: '#comment-internal-end'
              - include: '#argument'

          - include: '$self'

  command-call-standard:
    comment: Check if the command is any other legal command, ie, a standard command
    patterns:
      - comment: A command call can't be a comment, but this match will only be satisfied if the command is first after a pipe because comments are otherwise consumed earlier
        name: invalid.illegal.function-call.fish
        begin: \#
        end: (?=[\n)])

      - comment: Match an operator which cannot start a command call but does not stop the next characters from being interpreted as a command
        name: invalid.illegal.operator.fish
        match: (?:[&|<>^])

      - comment: Anonymous scope - A complete command comprising a name element and optional argument, redirection, and comment elements
        begin: (?=\S)
        end: |-
          (?x)
          (?# Look ahead for control operations)
          (?=
            (?:
              (?# Find control operations)
              [\n;&)]
            |
              (?# Find piping)
              (?:(?:[0-9]+)?(?:<|>|>>))?\|
            )
          )
        patterns:
          - comment: Anonymous scope - A name or block element. If a block is found, everything up to the `end` command is captured here. Note that redirection and process expansion can't start the element
            begin: (?![\s<>^%])
            end: (?=[\s;&)|<>])
            patterns:
              - comment: Look for block structures
                include: '#command-call-block-rewrite'

              - comment: Look for loop control commands, which cannot take arguments. Unfortunately, without an effective scope stack we cannot restrict them to only be valid inside of loop constructs
                match: (?:break|continue)(?=\s+[^\s-\w]|\s*[\n;&)|<>])
                captures:
                  '0': {name: keyword.control.conditional.fish}

              - comment: Anonymous scope - A generic name element
                begin: (?!\s)
                end: (?=[\s;&)|<>])
                patterns:
                  - comment: A command name can't contain a command substitution. We match the whole line if no closing parenthesis is found, or until the end of the command name if the command substitution gets closed
                    comment: fish would match the whole command name invalid if there was a command substitution anywhere in it, but we can't look ahead that effectively
                    name: invalid.illegal.function-call.fish
                    begin: (?=\()
                    end: (?=[\s;&)|<>])
                    patterns:
                      - begin: \(
                        end: \)|(?=[\n;&)|<>])

                  - comment: Match an escaped newline in the command name, but don't use line-continuation because comments aren't allowed
                    name: constant.character.escape.fish
                    match: \\\n

                  - comment: Otherwise, treat the element as a fraction of a name made of arbitrary strings (which breaks at an escaped newline)
                    name: variable.function.fish
                    begin: (?!\s)
                    end: (?=[\s;&()|<>]|\\\n)
                    patterns:
                      - include: '#string'

          - comment: A command name can't begin with a process expansion operator (however the variable expansion operator '$' is allowed)
            name: invalid.illegal.function-call.fish
            begin: \%
            end: (?=[\s;&)|<>])
            patterns:
              - include: '#string'

          - comment: Redirection can immediately follow the command name, without whitespace separation
          - include: '#redirection'

          - comment: Anonymous scope - An argument or comment element. We rely on these elements needing to be separated by whitespace
            # name: anon-argument
            begin: (?:[^\n\S]+)
            # beginCaptures:
            #   '0': {name: anon.space}
            comment: Match any whitespace character that isn't the newline
            end: (?=[\s;&)|])
            end: |-
              (?x)
              (?# Look ahead for control operations)
              (?=
                (?:
                  (?# Find whitespace or simple control operations)
                  [\s;&)]
                |
                  (?# Find piping)
                  (?:(?:[0-9]+)?(?:<|>|>>))?\|
                )
              )
            patterns:
              - include: '#line-continuation'
              - include: '#comment-internal-end'
              - include: '#redirection'
              - include: '#argument'

  command-substitution:
    patterns:
      - comment: Capture "(...)" or "(...)[...]"
        begin: (?=\()
        end: (?<=\))(?!\[)|(?<=\])
        patterns:
          - name: meta.parens.command-substitution.fish
            begin: \(
            beginCaptures:
              '0': {name: punctuation.section.parens.begin.fish}
            end: \)
            endCaptures:
              '0': {name: punctuation.section.parens.end.fish}
            patterns:
              - comment: The inside of a command substitution is indistinguishable from a global scope
                include: '$self'

          - include: '#index-expansion'

  comment-external:
    patterns:
      - comment: A full or inline comment outside of any command call
        name: comment.line.external.fish
        begin: \#
        beginCaptures:
          '0': {name: punctuation.definition.comment.fish}
        end: \n

  comment-internal-end:
    patterns:
      - comment: An inline comment at the end of a command call. Does not consume the newline, thus allowing the command call to capture it and end
        name: comment.line.internal.end.fish
        begin: \#
        beginCaptures:
          '0': {name: punctuation.definition.comment.fish}
        end: (?=\n)

  index-expansion:
    patterns:
      - name: meta.brackets.index-expansion.fish
        comment: Note also that command substitution can only have a single index expansion
        begin: \[
        beginCaptures:
          '0': {name: punctuation.section.brackets.begin.fish}
        end: \]
        endCaptures:
          '0': {name: punctuation.section.brackets.end.fish}
        comment: The number of index expansion argument lists `[...]` should always be less than or equal to the number of variable expansion operators `$`. Unfortunately, we can do nothing to moderate that with this syntax schema; with a *.sublime-syntax and a scope stack it could be done. As it stands, "$$foo[...]" is the deepest that we can accurately highlight
        comment: In other words, the anonymous scope which contains the variable and the index expansion argument list should only be allowed to contain a single copy of each of those two things. We cannot enforce that without a scope stack. Our workaround is to allow an infinite number of these and hope the user can keep track of when there are too many
        patterns:
          - name: keyword.operator.fish
            match: \.\.

          - include: '#command-substitution'

          - include: '#variable-expansion'

          - comment: Manually recreate the #string rule with extra logic in unquoted strings, and don't repeat the meta.string.unquoted scope
          - include: '#string-quoted'
          - name: constant.numeric.fish
            match: (?:[0-9]+)(?=[\s;&)|<>'"]|\]|\.\.)
          - begin: (?![\s'"]|\.\.)
            end: (?=[\s;&)|<>'"]|\]|\.\.)
            comment: Begin/end string as before with the addition of breaking at a ']' or ".."
            patterns:
              - include: '#string-unquoted-patterns'

  line-continuation:
    comment: This rule should be included anywhere that escaping a newline and adding an arbitrary number of comment lines is permitted (which is pretty much everywhere in fish)
    patterns:
      - comment: Consume any number of alternating escaped newlines and lines which have nothing on them but comments
        begin: (?=\\\n)
        end: ^(?![\s\#])|\s(?![\s\#])
        comment: End when the first character of a line isn't whitespace or a comment character, or if the next character after some consumed whitespace isn't more whitespace or a comment character
        # name: free.continue
        patterns:
          - name: constant.character.escape
            match: \\\n

          - name: comment.line.continuation.fish
            begin: \#
            beginCaptures:
              '0': {name: punctuation.definition.comment.fish}
            end: \n

  redirection:
    patterns:
      - comment: This redirection pattern connects a file descriptor (either explicit or implied) and a file descriptor. As the '&' is necessary, this is a more strict pattern match and must be attended to first
        name: meta.redirection.fish
        begin: (?:([0-9]+)(<|>|>>)|(>>|\^\^|[<>]|(?<=^|\s)\^))(\&)
        beginCaptures:
          '1': {name: constant.numeric.file-descriptor.fish}
          '2': {name: keyword.operator.redirect.fish}
          '3': {name: keyword.operator.redirect.fish}
          '4': {name: keyword.operator.redirect.dereference.fish}
        comment: Begin at any of the redirections valid for a file descriptor (the '&' must be present). Note that the stderr redirection operator '^' must be preceded by whitespace and cannot be preceded by a file descriptor
        end: (?<=[^&\s]|\n)(?=[\s);&|<>])
        comment: End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the integer found before the end match
        patterns:
          - include: '#line-continuation'

          - comment: Evaluates to a string which may be an integer
            include: '#command-substitution'

          - comment: Evaluates to a string which may be an integer
            include: '#variable-expansion'

          - name: constant.numeric.file-descriptor.fish
            match: (?:[0-9]+)(?=[\s);&|<>])
          - name: keyword.operator.redirect.close.fish
            match: (?:-)(?=[\s);&|<>])

          - comment: Anything else is illegal
            name: invalid.illegal.file-descriptor.fish
            match: (?:\S+.*)$

      - comment: This redirection pattern connects a file descriptor (either explicit or implied) and a file path
        name: meta.redirection.fish
        begin: (?:([0-9]+)(<|>|>>)|(>>|\^\^|[<>]|(?<=^|\s)\^))(\?)?
        beginCaptures:
          '1': {name: constant.numeric.file-descriptor.fish}
          '2': {name: keyword.operator.redirect.fish}
          '3': {name: keyword.operator.redirect.fish}
          '4': {name: keyword.operator.redirect.clobber-test.fish}
        comment: Begin at any of the redirections valid for a file path (the '?' may optionally be used to prevent clobber). Note that the stderr redirection operator '^' must be preceded by whitespace and cannot be preceded by a file descriptor
        end: (?<=[^<>^?\s]|\n)(?=[\s);&|<>])|(?=\n)
        comment: End at anything that would end an argument, with the added condition that the character before the boundary cannot be the final character of the begin match or whitespace, thus allowing an arbitrary amount of whitespace between the begin match and the path found before the end match
        patterns:
          - include: '#line-continuation'

          - comment: Evaluates to a string so path cannot begin with '('
            include: '#command-substitution'

          - comment: Evaluates to a string so path cannot begin with '$'
            include: '#variable-expansion'

          - comment: Check for characters which are associated with redirection, so path cannot begin with them
            name: invalid.illegal.path.fish
            match: (?:(?:[&?]|[0-9]*[<>^]).*)$

          - comment: Use the function call match to build a file path, as the syntax is fairly similar (possibly identical, with exceptions caught above)
            name: meta.path.fish
            match: (?:\'(?:\\[\'\\]|[^\'\\])*\'|\"(?:\\[\"$\n\\]|[^\"$\n\\])*\"|(?:\\[abefnrtv $\\*?#(){}\[\]<>^&;|"']|(?<=^|\s)\\[~%]|\\[xX][0-9A-Fa-f]{1,2}|\\[0-7]{1,3}|\\u[0-9A-Fa-f]{1,4}|\\U[0-9A-Fa-f]{1,8}|\\c[?-~]|[^\s$\\*?~%#()<>&|;"']|\\(?=[^abefnrtv\s$\\*?#(){}\[\]<>^&;|"'xXuUc])|(?<=\S|\\ )\\\n|(?<=\S|\\ )[~%#])+)+

  string:
    patterns:
      - include: '#string-quoted'
      - include: '#string-unquoted'

  string-quoted:
    patterns:
      - name: string.quoted.single.fish
        begin: \'
        beginCaptures:
          '0': {name: punctuation.definition.string.begin.fish}
        end: \'
        endCaptures:
          '0': {name: punctuation.definition.string.end.fish}
        patterns:
          - comment: Only accepted escapes are \' and \\
            name: constant.character.escape.fish
            match: \\[\'\\]

      - name: string.quoted.double.fish
        begin: \"
        beginCaptures:
          '0': {name: punctuation.definition.string.begin.fish}
        end: \"
        endCaptures:
          '0': {name: punctuation.definition.string.end.fish}
        patterns:
          - comment: Only accepted escapes are \<newline>, \", \\, and \$
            name: constant.character.escape.fish
            match: \\[\n\"\\$]

          - comment: Variable expansion is the only expansion accepted
            include: '#variable-expansion'

  string-unquoted:
    patterns:
      - comment: Treat a sequence of integers (with possible decimal separator) as a standalone constant. Do this separate to string-unquoted-pattens so we can ensure it is a string solely of numbers
        name: meta.string.unquoted.fish constant.numeric.fish
        match: (?:[0-9\.]+)(?=[\s;&)|<>'"])

      - name: meta.string.unquoted.fish
        begin: (?!['"])
        comment: Begin unquoted string if there are no quotes present
        end: (?=[\s;&()|<>'"$])|(?=\\\n)
        comment: End unquoted string at whitespace, control operators, quoted strings, a variable expansion, or an upcoming escaped newline
        patterns:
          - include: '#string-unquoted-patterns'

  string-unquoted-patterns:
    comment: Describe contents of an unquoted string separately for ease of recursion
    patterns:
      - comment: This list follows the order given in official fish documentation, with the addition of additional checks made on the ~ and % characters which only need escaping if they appear at the front of an argument
        name: constant.character.escape.fish
        match: |-
          (?x)
          \\[abefnrtv $\\*?#(){}\[\]<>^&|;"']
          |
          (?<=^|\s)\\[~%]
          |
          \\[xX][0-9A-Fa-f]{1,2}
          |
          \\[0-7]{1,3}
          |
          \\u[0-9A-Fa-f]{1,4}
          |
          \\U[0-9A-Fa-f]{1,8}
          |
          \\c[?-~]

      - name: meta.braces.brace-expansion.fish
        begin: \{
        beginCaptures:
          '0': {name: punctuation.section.braces.begin.fish}
        end: \}
        endCaptures:
          '0': {name: punctuation.section.braces.end.fish}
        patterns:
          - name: punctuation.section.braces.separator.fish
            match: \,

          - include: '#command-substitution'

          - include: '#variable-expansion'

          - comment: Manually recreate the #string rule with extra logic in unquoted strings, and don't repeat the meta.string.unquoted scope
          - include: '#string-quoted'
          - name: constant.numeric.fish
            match: (?:[0-9\.]+)(?=[\s;&)|<>'"]|\}|\,)
          - begin: (?![\s'"])
            end: (?=[\s;&)|<>'"]|\}|\,)
            comment: Begin/end string as before with the addition of breaking at a '}' or ','
            patterns:
              - name: constant.character.escape.fish
                match: \\\,
              - include: '#string-unquoted-patterns'

      - name: meta.wildcard-expansion.fish
        match: (\*\*)|(\*)|(\?)
        captures:
          '1': {name: keyword.operator.double-star.fish}
          '2': {name: keyword.operator.single-star.fish}
          '3': {name: keyword.operator.question-mark.fish}

  variable-expansion:
    patterns:
      - include: '#variable-expansion-illegal'

      - comment: Capture "$foo" or "$foo[]" or "$$foo[][]" etc
        name: meta.variable-expansion.fish
        begin: (?=\$)
        end: (?<=[\$\w])(?=[^\$\w\[])|(?<=\])(?!\[)
        patterns:
          - comment: Match any depth of recursive variable expansions
          - name: variable.other.fish
            begin: \$
            beginCaptures:
              '0': {name: punctuation.definition.variable.fish}
            end: (?<=[\$\w])(?=[^\$\w])
            patterns:
              - include: '#variable-expansion-illegal'
              - include: '#variable-expansion-simple'

          - comment: Match any number of consecutive index expansions
          - include: '#index-expansion'

  variable-expansion-simple:
    comment: Describe variable expansion that has no index expansion separately
    patterns:
      - name: variable.other.fish
        begin: \$
        beginCaptures:
          '0': {name: punctuation.definition.variable.fish}
        end: (?<=[\$\w])(?=[^\$\w])
        patterns:
          - include: '#variable-expansion-illegal'
          - include: '#variable-expansion-simple'

  variable-expansion-illegal:
    comment: Describe illegal variable expansions separately
    patterns:
      - comment: A lone '$' in a scope, or an attempt to expand a variable starting with a nonword character, is an error. These boundaries are the same as for meta.string.unquoted
        name: invalid.illegal.variable-expansion.fish
        match: \$(?:(?=[,'"\]}\s);&|])|[^\w\$][^$,'"\]}\s);&|]*)

firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|case|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(case|else|end)\b)
keyEquivalent: ^~S
