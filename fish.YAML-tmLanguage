# [PackageDev] target_format: plist, ext: tmLanguage
name: Shell Script (fish)
scopeName: source.fish
fileTypes: [fish]
uuid: a6b750ed-a12a-43c1-84e7-689ac7e2fbc9

patterns:
- comment: These are the patterns which can appear in the base scope
- include: '#block'
- include: '#command-call'
- include: '#comment'
- include: '#control-operator'
- include: '#escape-character'

# Style guide:
# - keyword.control is applied to control operators such as ;, &, and | because although keyword.operator is suggested for symbols in general, these symbols are important to controlling program flow
# - keyword.control.conditional is applied to all control keywords that are actually words (if, else, end, etc.)
# - support.function is applied to standalone commands rather than variable.function because this is a scripting language and we can reliably act as though any command will be provided to the user as if it were part of a base framework
# - constant.character.escape is used for the backslash at the end of a line which causes line continuation because technically that backslash is "escaping" the literal newline which appears in the unquoted string environment which the shell assumes you are in. In this sense, the backslash is indeed an escape character
# - Individual arguments in function calls do not get the variable.parameter label because that swiftly becomes the overwhelming majority of all words in a program

#! \todo blocks (function, then for-in)
#! \todo add comment-inline to the recursive command-call. no point adding comment because recursive will /always/ have ended by the time a full line comment shows up
#! \todo item-access for command-substitution
#! \todo constants, including any command character when preceded by a slosh to escape it (eg, \;, \&, etc)
#! \todo add special behaviour to ~ as an argument
#! \todo redirection
#! \todo a specific version of command-call which is just test and the possible expressions all highlighted special, as well as the [ ] form of test
#! \todo `"echo" what` is valid syntax and executes. add a form of command-call where the command is in quotes, and highlight the quotes to match the command. escaped newlines within double quotes are valid. I think you can actually use string to do this, maybe by starting with a lookahead for a quote, ending with a lookback for a quote, and matching only a string inside of it then naming it all support.function.user. even though fish will never not error on a quoted command that has whitespace (because no function will ever be found that has whitespace in its name), technically the syntax isn't invalid. we don't need to police the user and make sure their quoted command has no whitespace; it is valid to do so because as far as ST is concerned that function may well exist
#! \todo piping with | is more complicated than it seems, as fish expects a command to appear after the pipe. make a pattern match in command-call that is only valid inside of a command call that used the pipe, and matches from after a pipe until the end of the line, looking for command-call within it
#!  Hm, because it is possible to pipe the output of an entire block by putting the pipe after `end`, a better approach may be to make a command that STARTS with a pipe, and is normal after that. then it can check inside itself to see if it is ONLY a pipe with no command following it, and mark that as invalid syntax. that would supersede the need for pipe to be matched invalid from in control-operator

repository:
  argument:
    patterns:
    - name: meta.function-call.argument.fish
      comment: An argument is one of the fundamental units, however we define it by the very essence of not being any of the other fundamental units '#', '\', and the control operators (';', '&', and '|'). All those have special treatment when they appear in command-calls, so we attend to them uniquely
      begin: (?<=^|\s)(?!\s|#|$|\\$)
      comment: Begin arg at the boundary between whitespace (or begin of line for when command-call escapes its newline) and anything but whitespace, a comment character (because a lone # can't be an arg), a newline (to prevent blank lines being called args), or an escaped newline (because command-call can spot a lone \ and match it)
      comment: Known bug - ` echo \ #` is supposed to print " #" because the whitespace is forced to become a character and then the # isn't considered lone because forced whitespace precedes it. So "\ #" should be one arg
      end: (?<=\S)(?=\s|\)|;|&|\||$)
      comment: End arg if it precedes unescaped control operators. Everything else is fair game, and strings and variables are matched and properly highlighted if found
      patterns:
      # - include: '#constant' #! \todo This will be things like lone numbers and escape characters, even though fish doesn't treat numbers any differently
      - include: '#string'
      - include: '#variable'
      - include: '#command-substitution'

  block:
    patterns:
    - name: meta.block.begin.fish
      begin: \b(begin)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - include: '$self'

    - name: meta.block.while.fish
      begin: \b(while)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - include: '#loop-control-command'
      - include: '$self'

    - name: meta.block.if.fish
      begin: \b(if)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - name: keyword.control.conditional.fish
        match: \b(else(\s*if)?)\b
        comment: Having a meta scope just for the condition command is complicated and ultimately useless, so treat `else if` and `else` as standalone keywords and let the conditions scope like normal instances of command-call
      - include: '$self'

    #! \todo Needs work !! See the arbitrary-commands_for-block-development branch for the WIP of whatever I was doing last time I tried to fix this block
    - name: meta.block.for-in.fish
      begin: \b(for)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - begin: (?<=for)
        end: '^'
        patterns:  # nope, because of comments entering the scope this will never work. just make special "from command names to an endline or the next special demarcation point" scopes for for-var and in-listothings
        # better yet, don't be afraid of splitting block up into several matches, for the different types of block!
        - include: '$self'
        - begin: (\w+)(\s+((\\)\n)?)+(in)\s+
          beginCaptures:
            '1': {name: meta.function-call.argument.fish}
            '5': {name: keyword.control.conditional.fish}
          comment: Treat the varname to `for` like a normal argument
          end: '\n'
          contentName: meta.function-call.argument.fish
          patterns:
          - match: (\\)\n
            captures:
              '1': {name: constant.character.escape}
          - include: '#command-substitution'
          - match: \w+
            comment: Treat values to `in` like normal arguments
      - include: '$self'

    - name: meta.block.switch.fish
      begin: \b(switch)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - name: meta.block.switch.value.fish
        begin: (?<=switch)
        end: (?=;)|\n
        comment: Value ends before ';' or at a newline
        patterns:
        - include: '#comment'
        - include: '#comment-inline'
        - include: '#command-substitution'
        - include: '#string'
        - include: '#variable'
        - match: (\\)\n
          captures:
            '1': {name: constant.character.escape}
          comment: The value specification may contain a newline if it is escaped; consume the newline to prevent the value spec ending
      - name: meta.block.switch.case.fish
        begin: \b(case)\b
        beginCaptures:
          '0': {name: keyword.control.conditional.fish}
        end: (?=\b(case|end)\b)
        comment: Case block ends before a new case or the end of the switch block
        patterns:
        - name: meta.block.switch.case.wildcard.fish
          begin: (?<=case)
          end: (?=;)|\n
          comment: Wildcard ends before ';' or at a newline
          patterns:
          - include: '#comment'
          - include: '#comment-inline'
          - include: '#command-substitution'
          - include: '#string'
          - include: '#variable'
          - match: (\\)\n
            captures:
              '1': {name: constant.character.escape}
            comment: The wildcard specification may contain a newline if it is escaped; consume the newline to prevent the wildcard spec ending
        - include: '$self'
      - include: '#comment'
      - include: '#control-operator'

    #! \todo Needs work, see old function-definition element
    # don't forget to use entity.name.function on the function name in the declaration
    - name: meta.block.function.fish
      begin: \b(function)\b(?!\s+(-|&|\|))
      beginCaptures:
        '0': {name: keyword.control.conditional.fish}
      end: (end)(\s*(&))?
      endCaptures:
        '1': {name: keyword.control.conditional.fish}
        '3': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - include: '$self'

  command-call:
    patterns:
    - name: meta.function-call.recursive.fish
      comment: Check if command-call uses a builtin that takes another command-call as a sole argument, ie, to recursively contain another command-call. Because some builtins can instead take switches, or be backgrounded/piped (in which case they should be considered user commands), look ahead to ensure that no switches or bg/pipe control operators are found
      begin: \b((builtin|command|exec)|(and|not|or))\b(?!\s+(-|&|\|))
      comment: (?!\s+(-|&|\|)) is equivalent to (?= \s+ then \S except '-' '&' and '|')
      beginCaptures:
        '2': {name: support.function.builtin.fish}
        '3': {name: keyword.operator.word.fish}
      end: (?=\)|;)|(?<=\n|&|\|)
      comment: Recursive command-call ends before ')' or ';', and just after a newline, '&', or '|'. Standard command-call will have consumed the '&' or '|'. Unfortunately, we cannot help but end after any newline we encounter, as the standard command-call only ends when it consumes a newline (allowing us to insert comments by having the comment consume its newline and prevent command-call matching it) and we cannot distinguish between a newline that was consumed by a command and a newline that was consumed by a comment. Put simply, this means that when a recursive command-call reaches a newline before its first standard command-call, the scope ends and the standard command-call on the next line loses the recursive command-call scope
      patterns:
      - include: '#command-call'
      - match: (\\)\n
        captures:
          '1': {name: constant.character.escape}

    - name: invalid.illegal.function.fish
      comment: Search for illegal builtin commands by name
      begin: \b(case|else|end)\b
      comment: These functions aren't valid outside of their blocks
      end: $\n?

    - name: meta.function-call.standard.fish
      comment: If the above match for recursive commands failed, try and match legal standard commands
      begin: \b([\w][\w-]*)\b
      beginCaptures:
        '1': {name: support.function.user.fish}
      end: (?=\)|;)|\n|(&|\|)
      endCaptures:
        '1': {name: keyword.control.fish punctuation.definition.keyword.fish}
      comment: command-call ends before ')' or ';', and at a newline, '&', or '|'. Those last two control operators must be part of a command, so consume them here
      patterns:
      - include: '#argument'
      - include: '#comment'
      - include: '#comment-inline'
      - match: (\\)\n
        captures:
          '1': {name: constant.character.escape}
        comment: command-call may contain a newline if it is escaped; consume the newline to prevent the command-call ending

  command-substitution:
    patterns:
    - name: meta.command-substitution.fish
      comment: The inside of a command substitution is indistinguishable from a global scope
      begin: \(
      beginCaptures:
        '0': {name: keyword.control.command-substitution.begin.fish punctuation.definition.keyword.fish}
      end: \)
      endCaptures:
        '0': {name: keyword.control.command-substitution.end.fish punctuation.definition.keyword.fish}
      patterns:
      - include: '$self'

  comment:
    patterns:
    - name: comment.line.fish
      comment: Consumes the remainder of a line after any character which marks the start of a scope with no commands in it. Consumes the newline, thus hiding the entire comment from any scope which seeks newlines
      match: (?<=^|else|end|\(|;|&|\|)\s*(#).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.fish}

  comment-inline:
    patterns:
    - name: comment.line.insert.fish
      comment: Separate from comment as this is only valid inside of command-call. Does not consume the newline, thus allowing command-call to capture it and end. Note that a comment-inline won't start if escaped whitespace precedes the '#'
      match: (?<=[^\\]\s)(#).*$
      captures:
        '1': {name: punctuation.definition.comment.fish}

  control-operator:
    patterns:
    - name: keyword.control.fish punctuation.definition.keyword.fish
      match: ;
      comment: This is the only operator which is allowed to exist alone on a line. The other control operators are '&' and '|' however they must be preceded by a command, so command-call matches those
    - name: invalid.illegal.control.fish
      match: (?<=^|\(|;|&|\|)\s*(&|\|).*$\n?
      comment: These two control operators, '&' and '|', must be preceded by a command, so command patterns match them when they are valid. If they are found in the global scope or first inside a command-substitution, that means they are dangling

  escape-character:
    patterns:
    - name: constant.character.escape
      match: \\(?=\n)
      comment: This match should only be needed for an escaped newline which is not part of any command-call, like if it comes alone on a line. No need to consume the newline
    - name: invalid.illegal.escape.fish
      match: (?<=^|\(|;|&|\|)\s*\\(?!\n).*$\n?
      comment: Unless the user has a function starting with '\', a line beginning with '\' is almost certainly a typo

  loop-control-command:
    patterns:
    - begin: \b(break|continue)\b(?!\s+(-|\w))
      comment: These commands only work as loop control when they are used without arguments
      beginCaptures:
        '1': {name: keyword.control.conditional.fish}
      end: (?=;)|\n|(&)
      endCaptures:
        '1': {name: keyword.control.fish punctuation.definition.keyword.fish}
      patterns:
      - include: '#comment-inline'
      - include: '#control-operator'
      - include: '#escape-character'

  # fish strings accept very few escape codes, and make only a few simple distinctions between the single- and double-quoted variants
  string:
    patterns:
    - name: string.quoted.single.fish
      begin: \'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \'
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\'\\]
        comment: Only accepted escapes are \' and \\
    - name: string.quoted.double.fish
      begin: \"
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \"
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\"$\n\\]
        comment: Only accepted escapes are \", \$, \<newline>, and \\
      - include: '#variable'

  variable:
    patterns:
    - name: meta.item-access.fish
      begin: (\$)\w+(?=\[)
      beginCaptures:
        '0': {name: variable.other.fish }
        '1': {name: punctuation.definition.variable.fish }
      end: (?<=\])
      patterns:
      - name: meta.item-access.arguments.fish
        begin: \[
        beginCaptures:
          '0': {name: punctuation.definition.arguments.begin.fish }
        end: \]
        endCaptures:
          '0': {name: punctuation.definition.arguments.end.fish }
        patterns:
        - include: '#variable'
          comment: Not even fish does its item-access highlighting this well
        # - include: '#constant' # Once it's written

    - name: variable.other.fish
      comment: fish variables can only be word characters and no special treatment is necessary
      match: (\$)\w+(?=\W)
      captures:
        '1': {name: punctuation.definition.variable.fish }

  # Inherited constructs; to be rewritten

  function-definition:
    patterns:
    - name: meta.function.fish
      begin: \b(function)\s+([^\s\\]+)(?:\s*(\(\)))?
      beginCaptures:
        '1': {name: storage.type.function.fish}
        '2': {name: entity.name.function.fish}
        '3': {name: punctuation.definition.arguments.fish}
      end: ;|&|$
      endCaptures:
        '1': {name: punctuation.definition.function.fish}
      patterns:
      - include: $self

  logical-expression:
    patterns:
    - comment: do we want a special rule for ( expr )?
      name: keyword.operator.logical.fish
      match: =[=~]?|!=?|<|>|&&|\|\|
    # - name: keyword.operator.logical.fish
    #   match: (?<!\S)-(nt|ot|ef|eq|ne|l[te]|g[te]|[a-hknoprstuwxzOGLSN])

  math:
    patterns:
    - name: keyword.operator.arithmetic.fish
      match: (\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|<[<=]?|>[>=]?|==|!=|^|\|{1,2}|&{1,2}|\?|\:|,|=|[*/%+\-&^|]=|<<=|>>=)(?=(\s|$|\$|\())
      comment: Only match an operator if the element to the right is whitespace/newline, a variable, or command substitution
    - name: constant.numeric.hex.fish
      match: 0[xX]\h+
    - name: constant.numeric.octal.fish
      match: 0\d+
    - name: constant.numeric.other.fish
      match: \d{1,2}#[0-9a-zA-Z@_]+
    - name: constant.numeric.integer.fish
      match: \d+
    - include: '#variable'

  pathname:
    patterns:
    - name: keyword.operator.tilde.fish
      match: (?<=\s|:|=|^)~
    - name: keyword.operator.glob.fish
      match: \*|\?
    - name: meta.structure.extglob.fish
      begin: ([?*+@!])(\()
      beginCaptures:
        '1': {name: keyword.operator.extglob.fish}
        '2': {name: punctuation.definition.extglob.fish}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.extglob.fish}
      patterns:
      - include: $self

  redirection:
    patterns:
    - name: string.interpolated.process-substitution.fish
      begin: '[><]\('
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - include: $self
    - comment: 'valid: &>word >&word >word [n]>&[n] [n]<word [n]>word [n]>>word [n]<&word
        (last one is duplicate)'
      name: keyword.operator.redirect.fish
      match: '&>|\d*>&\d*|\d*(>>|>|<)|\d*<&|\d*<>'

firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|case|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(case|else|end)\b)
keyEquivalent: ^~S
