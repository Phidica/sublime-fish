# [PackageDev] target_format: plist, ext: tmLanguage
name: Shell Script (fish)
scopeName: source.fish
fileTypes: [fish]
uuid: a6b750ed-a12a-43c1-84e7-689ac7e2fbc9

patterns:
- include: '#command'
- include: '#comment'
# - include: '#function-definition'
# - include: '#interpolation'
# - include: '#keyword'
# - include: '#list'
# - include: '#logical-expression'
# - include: '#loop'
# - include: '#math'
# - include: '#pathname'
# - include: '#pipeline'
# - include: '#redirection'
# - include: '#string'
# - include: '#support'
# - include: '#variable'

repository:
  command:
    patterns:
    - name: meta.command.fish
      begin: \b([\w][\w+]*)\b
      beginCaptures:
        '1': {name: support.function.user.fish}
      # end: ;|&|\||(?=\))|$
      end: (?=\))|$
      comment: End might want to match the start of comments "#"?
      patterns:
      - include: '#command-substitution'
      - include: '#comment'
      - include: '#string'
      - include: '#variable'

  command-substitution:
    patterns:
    - name: meta.command-substitution.fish
      begin: \(
      beginCaptures:
        '0': {name: storage.type.command-substitution.fish}
      end: \)
      endCaptures:
        '0': {name: storage.type.command-substitution.fish}
      patterns:
      - include: '#command'

  comment:
    patterns:
    - name: comment.line.number-sign.fish
      match: (?<!\S)(#)(?!\{).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.fish}

  function-definition:
    patterns:
    - name: meta.function.fish
      begin: \b(function)\s+([^\s\\]+)(?:\s*(\(\)))?
      beginCaptures:
        '1': {name: storage.type.function.fish}
        '2': {name: entity.name.function.fish}
        '3': {name: punctuation.definition.arguments.fish}
      end: ;|&|$
      endCaptures:
        '1': {name: punctuation.definition.function.fish}
      patterns:
      - include: $self

  interpolation:
    patterns:
    - name: string.interpolated.dollar.fish
      begin: \{\$
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \}
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - include: $self

  keyword:
    patterns:
    - name: keyword.control.fish
      match: \b(?:and|begin|break|case|continue|else|end|for|if|in|return|switch|while)\b
    - name: storage.modifier.fish
      match: (?<![-/])\b(?:set)\b

  list:
    patterns:
    - name: keyword.operator.list.fish
      match: ;|&&|&|\|\|

  logical-expression:
    patterns:
    - comment: do we want a special rule for ( expr )?
      name: keyword.operator.logical.fish
      match: =[=~]?|!=?|<|>|&&|\|\|
    # - name: keyword.operator.logical.fish
    #   match: (?<!\S)-(nt|ot|ef|eq|ne|l[te]|g[te]|[a-hknoprstuwxzOGLSN])

  loop:
    patterns:
    - name: meta.scope.for-loop.fish
      begin: \b(for)\s+(?=\({2})
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.for-in-loop.fish
      begin: \b(for)\s+((?:[^\s\\]|\\.)+)\b
      beginCaptures:
        '1': {name: keyword.control.fish}
        '2': {name: variable.other.loop.fish}
      end: \b(end)\b
      endCaptures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.while-loop.fish
      begin: \b(while)\b
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.case-block.fish
      match: \b(case)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.if-block.fish
      begin: \b(if)\b
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self

  math:
    patterns:
    - name: keyword.operator.arithmetic.fish
      match: (\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|<[<=]?|>[>=]?|==|!=|^|\|{1,2}|&{1,2}|\?|\:|,|=|[*/%+\-&^|]=|<<=|>>=)(?=(\s|$|\$|\())
      comment: Only match an operator if the element to the right is whitespace/endline, a variable, or command substitution
    - name: constant.numeric.hex.fish
      match: 0[xX]\h+
    - name: constant.numeric.octal.fish
      match: 0\d+
    - name: constant.numeric.other.fish
      match: \d{1,2}#[0-9a-zA-Z@_]+
    - name: constant.numeric.integer.fish
      match: \d+
    - include: '#variable'

  pathname:
    patterns:
    - name: keyword.operator.tilde.fish
      match: (?<=\s|:|=|^)~
    - name: keyword.operator.glob.fish
      match: \*|\?
    - name: meta.structure.extglob.fish
      begin: ([?*+@!])(\()
      beginCaptures:
        '1': {name: keyword.operator.extglob.fish}
        '2': {name: punctuation.definition.extglob.fish}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.extglob.fish}
      patterns:
      - include: $self

  pipeline:
    patterns:
    - name: keyword.operator.pipe.fish
      match: '[|!]'

  redirection:
    patterns:
    - name: string.interpolated.process-substitution.fish
      begin: '[><]\('
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - include: $self
    - comment: 'valid: &>word >&word >word [n]>&[n] [n]<word [n]>word [n]>>word [n]<&word
        (last one is duplicate)'
      name: keyword.operator.redirect.fish
      match: '&>|\d*>&\d*|\d*(>>|>|<)|\d*<&|\d*<>'

  # general: no expansion (brace expansion, parameter expansion, variable expansion) will take place, the parameter may contain spaces, and all escape sequences are ignored. Single quotes have no special meaning within double quotes and vice versa
  # exceptions:
    # single-quotes: Accepted escapes are \', \\
    # double-quotes: Variable expansion DOES happen. Accepted escapes are \", \\, \$, \ followed by a newline (deletes the backslash and the newline)

  string:
    patterns:
    - name: constant.character.escape.fish
      match: \\.
    - name: string.quoted.single.fish
      begin: ''''
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: ''''
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
    - name: string.quoted.double.fish
      begin: '"'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: '"'
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\$`"\\\n]
      - include: '#variable'
      # - include: '#interpolation'
      # I suspect #interpolation is a holdover from Bash; it seems to do bad things for fish so I'm disabling it for now
    - name: string.quoted.single.dollar.fish
      begin: \$'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: ''''
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.ansi-c.fish
        match: \\(a|b|e|f|n|r|t|v|\\|')
      - name: constant.character.escape.octal.fish
        match: \\[0-9]{3}
      - name: constant.character.escape.hex.fish
        match: \\([xX][0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})
      - name: constant.character.escape.control-char.fish
        match: \\c.

  support:
    patterns:
    - comment: Matches literal . (alias for source, may be deprecated in future)
      name: support.function.builtin.fish
      match: (?<=^|\s)(?::|\.)(?=\s|;|&|$)
    - name: support.function.builtin.fish
      match: (?<![-/])\b(?:abbr|alias|bg|bind|block|breakpoint|builtin|cd|command|commandline|complete|contains|count|dirh|dirs|echo|emit|eval|exec|exit|false|fg|fish|fish_config|fish_indent|fish_prompt|fish_realpath|fish_right_prompt|fish_update_completions|fish_vi_mode|funced|funcsave|function|functions|help|history|isatty|jobs|math|nextd|not|open|popd|prevd|printf|prompt_pwd|psub|pushd|pwd|random|read|return|set|set_color|source|status|string|suspend|test|trap|true|type|ulimit|umask|vared)\b

  variable:
    patterns:
    - name: variable.other.fish
      comment: fish variables are very simple, as they can only be word characters and little special treatment is necessary
      match: (\$)(\w+)(?=\W)
      captures:
        '1': {name: punctuation.definition.variable.fish }

firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(else|end)\b)
keyEquivalent: ^~S
