# [PackageDev] target_format: plist, ext: tmLanguage
name: Shell Script (fish)
scopeName: source.fish
fileTypes: [fish]
uuid: a6b750ed-a12a-43c1-84e7-689ac7e2fbc9

patterns:
- include: '#command-call'
- include: '#comment'
- include: '#control-operator'
- include: '#escape-character'
  # probably this global scope will only allow comment, command-call, and block, once I write a block structure (begin, if, function, ...)

# - include: '#function-definition'
# - include: '#keyword'
# - include: '#logical-expression'
# - include: '#loop'
# - include: '#math'
# - include: '#pathname'
# - include: '#redirection'
# - include: '#string'
# - include: '#support'
# - include: '#variable'

repository:
  argument:
    patterns:
    - name: meta.function-call.arguments.fish
      comment: An argument is one of the fundamental units, however we define it by the very essence of not being any of the other fundamental units '#', '\', and the control operators (';', '&', and '|'). All those have special treatment when they appear in command-calls, so we attend to them uniquely
      begin: (?<=^|\s)(?!\s|#|$|\\$)
      comment: Begin arg at the boundary between whitespace (or begin of line for when command-call escapes its newline) and anything but whitespace, a comment character (because a lone # can't be an arg), a newline (to prevent blank lines being called args), or an escaped newline (because command-call can spot a lone \ and match it)
      comment: Known bug - ` echo \ #` is supposed to print " #" because the whitespace is forced to become a character and then the # isn't considered lone because forced whitespace precedes it. So "\ #" should be one arg
      end: (?<=\S)(?=\s|\)|;|&|\||$)
      comment: End arg if it precedes unescaped control operators. Everything else is fair game, and strings and variables are matched and properly highlighted if found
      patterns:
      # - include: '#constant' #! \todo This will be things like lone numbers and escape characters, even though fish doesn't treat numbers any differently
      - include: '#string'
      - include: '#variable'
      - include: '#command-substitution'

  command-call:
    patterns:
    - name: meta.function-call.recursive.fish
      comment: First check if command-call uses one of the builtins that can specifically take another command-call as a sole argument, ie, to recursively contain another command-call. Because some of these builtins can instead take switches, or be backgrounded/piped (in which case they should be considered user commands), look ahead to ensure that no switches or bg/pipe control operators are found
      begin: \b((builtin|command|exec)|(and|not|or))\s+(?!\s|-|&|\|)
      beginCaptures:
        '2': {name: support.function.builtin.fish}
        '3': {name: keyword.control.fish}
      end: (?=\)|;)|(?<=\n|&|\|)
      comment: Recursive command-call ends before ')' or ';', and just after a newline, '&', or '|'. Standard command-call will have consumed the '&' or '|'. Unfortunately, we cannot help but end after any newline we encounter, as the standard command-call only ends when it consumes a newline (allowing us to insert comments by having the comment consume its newline and prevent command-call matching it) and we cannot distinguish between a newline that was consumed by a command and a newline that was consumed by a comment. This simply means that when a recursive command-call reaches a newline before its first standard command-call, the scope ends and the standard command-call on the next line loses the recursive command-call scope
      patterns:
      - include: '#command-call'
      - match: (\\)\n
        captures:
          '1': {name: constant.character.escape}

    - name: meta.function-call.standard.fish
      comment: If the above match for recursive commands failed, try and match standard commands
      begin: \b([\w][\w-]*)\b
      beginCaptures:
        '1': {name: support.function.user.fish}
      end: (?=\)|;)|\n|(&|\|)
      endCaptures:
        '1': {name: keyword.control.fish}
      comment: command-call ends before ')' or ';', and at a newline, '&', or '|'. Those last two control operators must be part of a command, so consume them here
      patterns:
      - include: '#argument'
      - include: '#comment'
      - include: '#comment-inline'
      - match: (\\)\n
        captures:
          '1': {name: constant.character.escape}
        comment: command-call may contain a newline if it is escaped; consume the newline to prevent the command-call ending

  command-substitution:
    patterns:
    - name: meta.command-substitution.fish
      comment: If an unescaped newline is encountered within a command-substitution, a command-call ends and on the next line a new one may begin
      begin: \(
      beginCaptures:
        '0': {name: constant.character.command-substitution.fish}
      end: \)
      endCaptures:
        '0': {name: constant.character.command-substitution.fish}
      patterns:
      - include: '#command-call'
      - include: '#comment'
      - include: '#control-operator'
      - include: '#escape-character'

  comment:
    patterns:
    - name: comment.line.number-sign.fish
      comment: Consumes an entire line or the remainder of a line after a control operator, including the newline, thus hiding the entire comment from whatever scope we're in
      match: (?<=^|;|&|\|)\s*(#).*$\n?
      captures:
        '1': {name: punctuation.definition.comment.fish}

  comment-inline:
    patterns:
    - name: comment.inline.number-sign.fish
      comment: Separate from comment as this is only valid inside of command-call. Does not consume the newline, thus allowing command-call to capture it and end. Note that a comment-inline won't start if escaped whitespace precedes the '#'
      match: (?<=[^\\]\s)(#).*$
      captures:
        '1': {name: punctuation.definition.comment.fish}

  control-operator:
    patterns:
    - name: keyword.control.fish
      match: ;
      comment: This is the only operator which is allowed to exist alone on a line. The other control operators are '&' and '|' however they must be preceded by a command, so command-call matches those
    - name: invalid.illegal.control.fish
      match: (^|(?<!\())\s*(&|\|).*$\n?
      comment: These two control operators, '&' and '|', must be preceded by a command, so command-call matches them when they are valid. If they are found in the global scope or first inside a command-substitution, that means they are dangling

  escape-character:
    patterns:
    - name: constant.character.escape
      match: \\(?=\n)
      comment: This match should only be needed for an escaped newline which is not part of any command-call, like if it comes alone on a line. No need to consume the newline
    - name: invalid.illegal.escape.fish
      match: (^|(?<!\())\s*(\\\\).*$\n?
      comment: Unless the user has a function called '\', this is most likely a typo

  function-definition:
    patterns:
    - name: meta.function.fish
      begin: \b(function)\s+([^\s\\]+)(?:\s*(\(\)))?
      beginCaptures:
        '1': {name: storage.type.function.fish}
        '2': {name: entity.name.function.fish}
        '3': {name: punctuation.definition.arguments.fish}
      end: ;|&|$
      endCaptures:
        '1': {name: punctuation.definition.function.fish}
      patterns:
      - include: $self

  keyword:
    patterns:
    - name: keyword.control.fish
      match: \b(?:and|begin|break|case|continue|else|end|for|if|in|return|switch|while)\b
    - name: storage.modifier.fish
      match: (?<![-/])\b(?:set)\b

  logical-expression:
    patterns:
    - comment: do we want a special rule for ( expr )?
      name: keyword.operator.logical.fish
      match: =[=~]?|!=?|<|>|&&|\|\|
    # - name: keyword.operator.logical.fish
    #   match: (?<!\S)-(nt|ot|ef|eq|ne|l[te]|g[te]|[a-hknoprstuwxzOGLSN])

  loop:
    patterns:
    - name: meta.scope.for-loop.fish
      begin: \b(for)\s+(?=\({2})
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.for-in-loop.fish
      begin: \b(for)\s+((?:[^\s\\]|\\.)+)\b
      beginCaptures:
        '1': {name: keyword.control.fish}
        '2': {name: variable.other.loop.fish}
      end: \b(end)\b
      endCaptures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.while-loop.fish
      begin: \b(while)\b
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.case-block.fish
      match: \b(case)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self
    - name: meta.scope.if-block.fish
      begin: \b(if)\b
      end: \b(end)\b
      captures:
        '1': {name: keyword.control.fish}
      patterns:
      - include: $self

  math:
    patterns:
    - name: keyword.operator.arithmetic.fish
      match: (\+{1,2}|-{1,2}|!|~|\*{1,2}|/|%|<[<=]?|>[>=]?|==|!=|^|\|{1,2}|&{1,2}|\?|\:|,|=|[*/%+\-&^|]=|<<=|>>=)(?=(\s|$|\$|\())
      comment: Only match an operator if the element to the right is whitespace/newline, a variable, or command substitution
    - name: constant.numeric.hex.fish
      match: 0[xX]\h+
    - name: constant.numeric.octal.fish
      match: 0\d+
    - name: constant.numeric.other.fish
      match: \d{1,2}#[0-9a-zA-Z@_]+
    - name: constant.numeric.integer.fish
      match: \d+
    - include: '#variable'

  pathname:
    patterns:
    - name: keyword.operator.tilde.fish
      match: (?<=\s|:|=|^)~
    - name: keyword.operator.glob.fish
      match: \*|\?
    - name: meta.structure.extglob.fish
      begin: ([?*+@!])(\()
      beginCaptures:
        '1': {name: keyword.operator.extglob.fish}
        '2': {name: punctuation.definition.extglob.fish}
      end: (\))
      endCaptures:
        '1': {name: punctuation.definition.extglob.fish}
      patterns:
      - include: $self

  redirection:
    patterns:
    - name: string.interpolated.process-substitution.fish
      begin: '[><]\('
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \)
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - include: $self
    - comment: 'valid: &>word >&word >word [n]>&[n] [n]<word [n]>word [n]>>word [n]<&word
        (last one is duplicate)'
      name: keyword.operator.redirect.fish
      match: '&>|\d*>&\d*|\d*(>>|>|<)|\d*<&|\d*<>'

  # fish strings accept very few escape codes, and make only a few simple distinctions between the single- and double-quoted variants
  string:
    patterns:
    - name: string.quoted.single.fish
      begin: \'
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \'
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\'\\]
        comment: Only accepted escapes are \' and \\
    - name: string.quoted.double.fish
      begin: \"
      beginCaptures:
        '0': {name: punctuation.definition.string.begin.fish}
      end: \"
      endCaptures:
        '0': {name: punctuation.definition.string.end.fish}
      patterns:
      - name: constant.character.escape.fish
        match: \\[\"$\n\\]
        comment: Only accepted escapes are \", \$, \<newline>, and \\
      - include: '#variable'

  support:
    patterns:
    - comment: Matches literal . (alias for source, may be deprecated in future)
      name: support.function.builtin.fish
      match: (?<=^|\s)(?::|\.)(?=\s|;|&|$)
    - name: support.function.builtin.fish
      match: (?<![-/])\b(?:abbr|alias|bg|bind|block|breakpoint|builtin|cd|command|commandline|complete|contains|count|dirh|dirs|echo|emit|eval|exec|exit|false|fg|fish|fish_config|fish_indent|fish_prompt|fish_realpath|fish_right_prompt|fish_update_completions|fish_vi_mode|funced|funcsave|function|functions|help|history|isatty|jobs|math|nextd|not|open|popd|prevd|printf|prompt_pwd|psub|pushd|pwd|random|read|return|set|set_color|source|status|string|suspend|test|trap|true|type|ulimit|umask|vared)\b

  variable:
    patterns:
    - name: meta.item-access.fish
      begin: (\$)\w+(?=\[)
      beginCaptures:
        '0': {name: variable.other.fish }
        '1': {name: punctuation.definition.variable.fish }
      end: (?<=\])
      patterns:
      - name: meta.item-access.arguments.fish
        begin: \[
        beginCaptures:
          '0': {name: punctuation.definition.arguments.begin.fish }
        end: \]
        endCaptures:
          '0': {name: punctuation.definition.arguments.end.fish }
        patterns:
        - include: '#variable'
          comment: Not even fish does its item-access highlighting this well
        # - include: '#constant' # Once it's written

    - name: variable.other.fish
      comment: fish variables can only be word characters and no special treatment is necessary
      match: (\$)\w+(?=\W)
      captures:
        '1': {name: punctuation.definition.variable.fish }


firstLineMatch: ^#!.*\b(fish)|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-
foldingStartMarker: \b(begin|for|if|else|function|switch|while)\b|(\{)$
foldingStopMarker: ^\s*(\}|(else|end)\b)
keyEquivalent: ^~S
